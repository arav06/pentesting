# PowerShell 
> Arav Budhiraja | 16th August 2021

## Basic Powershell commands

<b>Every command/text typed in Powershell is known as a cmdlet/command-let</b>

Most cmdlets have the following syntax:

```powershell
Verb-Noun
```

Powershell is NOT CASE SENSITIVE 


#### View all aliases:

```powershell
Get-Alias
```
 
It's alias is gal

### To list files:

```powershell
Get-ChildItem
```

***

To display hidden files, we would append '-Hidden'

```powershell
Get-ChildItem -Hidden
```

***

We can also specify if we wish to view only files or directories by appending '-File' or '-Directory'

```powershell
Get-ChildItem -File
```

```powershell
Get-ChildItem -Directory
```

***

To view all the files and subfolders of a directory, we can append '-Recurse'

```powershell
Get-ChildItem -Recurse
```

Commands such as 'ls' and 'dir' are aliases of the above

Or we could append '-?' to the end of the cmdlet

```powershell
Get-ChildItem -?
```

### Manual page for a cmdlet

```powershell
Get-Help <Cmdlet Name>
```

If we wish to get a lot of help for a cmdlet, we can update the manual using 'Update-Help'. Once updating the manual, we will have to run powershell as the admin

```powershell
Update-Help
```

### Display the date and time

```powershell
Get-Date
```

### Filter the output of cmdlets

When running Get-ChildItem, the output contains 4 columns.

```md
Mode		LastWriteTime		Length Name
----		--------------		------ ----
d-----	  12-06-2021 17:34		     	Arav
d-r---	  16-08-2021 21:39		     	Public
```

To parse the output of a cmdlet to another cmdlet, we will use the pipe operator |
To filter output, we will use the 'Select-Object' cmdlet. It's alias is 'Select'

***

To select the values from the column named 'Name'

```powershell
Get-ChildItem | Select-Object Name
```

Output:

```txt
Name
----
Arav
Public
```

***

Another way to select the values from a column such as Mode

```powershell
(Get-ChildItem).Mode
```

Output:

```md
d-----
d-r---
```

***

To select the first row

```powershell
Get-ChildItem | Select-Object -First 1
```

Output:

```md
Mode		LastWriteTime		Length Name
----		--------------		------ ----
d-----	  12-06-2021 17:34		     	Arav
```

***

And to select the last row

```powershell
Get-ChildItem | Select-Object -Last 1
```

Output:

```md
Mode		LastWriteTime		Length Name
----		--------------		------ ----
d-r---	  16-08-2021 21:39		     	Public
```

***

To select a row based upon its Index

```powershell
Get-ChildItem | Select-Object -Index 0
```

Output:

```md
Mode		LastWriteTime		Length Name
----		--------------		------ ----
d-----	  12-06-2021 17:34		     	Arav
```

***

To select the value of the 'Name' column of the first row

```powershell
Get-ChildItem | Select-Object -Index 0 | Select-Object Name
```

Output:

```txt
Name
----	
Arav
```

***

Get a lot of information from the output of a cmdlet

```powershell
Get-ChildItem | Select-Object *
```

### Functions 

To view the functions for a specific value, we can use the 'Get-Member' cmdlet. To use it, we will have to parse the output from a cmdlet into it.

```powershell
(Get-ChildItem).Name | Select -First 1 |  Get-Member
```

This will display a lot of functions which can be used on that value

***

Display the length of the value

```powershell
((Get-ChildItem).Name | Select -First 1).Length
```

Output:

```md
4
```

***

Convert value to Uppercase

```powershell
((Get-ChildItem).Name | Select -First 1).ToUpper()
```

Output:

```md
ARAV
```

***

Convert value to Lowercase

```powershell
((Get-ChildItem).Name | Select -First 1).ToLower()
```

Output:

```md
arav
```

***

Check if the value starts with a specified word/letter

```powershell
((Get-ChildItem).Name | Select -First 1).startsWith("A")
```

Output:

```md
True
```

***

Checks if the value ends with a specified word/letter

```powershell
((Get-ChildItem).Name | Select -First 1).endsWith("y")
```

Output:

```md
False
```

***

Find the index number of a specified character

```powershell
((Get-ChildItem).Name | Select -First 1).IndexOf("r")
```

Output:

```md
1
```

***

Insert a string/word at a specific postion

```powershell
((Get-ChildItem).Name | Select -First 1).Insert(4,"-1234")
```

Output:

```md
Arav-1234
```

***

Check if two values are the same

Insert a string/word at a specific postion

```powershell
((Get-ChildItem).Name | Select -First 1).Equals("Arav")
```

Output:

```md
True
```

### Displaying output

This can be done with 'Write-Output' which is used to display a string of text

```powershell
Write-Output "Hello World!"
```

Output:

```md
Hello World!
```

It's aliases are 'echo' and 'write'


### Writing output of a cmdlet to a file

If we want to write the output of a cmdlet to a file, we can use 'Out-File'

```powershell
Get-ChildItem | Out-File test.txt
```

This can also be done with 'Tee-Object'. It's alias is 'tee'

```powershell
Get-ChildItem | Tee-Object test.txt
```

Instead of using cmdlets, we can also use the operations '>' and '>>'

When using '>', all the contents of a file are replaced with the output of the cmdlet
However when using '>>', the output of the cmdlet is appended to the file

```powershell
Write-Output "test" > test.txt
```

Here, a file named 'test.txt' is created which contains 'test'. 

```powershell
Write-Output "test2" > test.txt
```

Now it's content is 'test2'

```powershell
Write-Output "test3" >> test.txt
```

And now it's content is 

```md
test2
test3
```

### Formatting Output

To do so, we will pipe the output of a cmdlet into the 'Format' cmdlet

We can use 'Format-Wide' to remove rows and columns. It's alias is 'fw'

```powershell
Get-ChildItem | Format-Wide
```

Output:

```md
Arav	    Public
```

***

To display the hexdump of the files, we can use 'Format-Hex'. Since the hexdump of a folder can not be displayed, I have created a file named test.txt which contains 'This is a test :)'. It's alias is 'fhx'

```powershell
Get-ChildItem | Format-Hex
```

Output:

```md
           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F

00000000   FF FE 54 00 68 00 69 00 73 00 20 00 69 00 73 00  .Ã¾T.h.i.s. .i.s.
00000010   20 00 61 00 20 00 74 00 65 00 73 00 74 00 20 00   .a. .t.e.s.t. .
00000020   3A 00 29 00 0D 00 0A 00                          :.).....
```

***

If we wish to display a lot of details about folder/files, we can use 'Format-List'. It's alias is 'fl'

```powershell
Get-ChildItem | Select-Object -First 2 | Format-List
```

Output:

```md
Name           : Arav
CreationTime   : 12-06-2021 21:32:48
LastWriteTime  : 12-06-2021 21:32:48
LastAccessTime : 16-08-2021 20:55:07
Mode           : d-----
LinkType       :
Target         : {}

Name           : Public
CreationTime   : 12-06-2021 21:22:18
LastWriteTime  : 12-06-2021 21:22:18
LastAccessTime : 16-08-2021 20:53:54
Mode           : d-r---
LinkType       :
Target         : {}
```

To view even more information, we can use 'Format-List *'

```powershell
Get-ChildItem | Select-Object -First 2 | Format-List *
```

Output:

```md
PSPath            : Microsoft.PowerShell.Core\FileSystem::C:\Users\Arav
PSParentPath      : Microsoft.PowerShell.Core\FileSystem::C:\Users\Arav
PSChildName       : Arav
PSDrive           : C
PSProvider        : Microsoft.PowerShell.Core\FileSystem
PSIsContainer     : True
Mode              : d-----
BaseName          : Arav
Target            : {}
LinkType          :
Name              : .config
FullName          : C:\Users\Arav
Parent            : Users
Exists            : True
Root              : C:\
Extension         : 
CreationTime      : 12-06-2021 21:32:48
CreationTimeUtc   : 12-06-2021 15:52:18
LastAccessTime    : 16-08-2021 20:55:07
LastAccessTimeUtc : 17-08-2021 03:00:45
LastWriteTime     : 12-06-2021 21:32:48
LastWriteTimeUtc  : 12-06-2021 15:52:18
Attributes        : Directory

PSPath            : Microsoft.PowerShell.Core\FileSystem::C:\Users\Public
PSParentPath      : Microsoft.PowerShell.Core\FileSystem::C:\Users\Public
PSChildName       : Public
PSDrive           : C
PSProvider        : Microsoft.PowerShell.Core\FileSystem
PSIsContainer     : True
Mode              : d-r---
BaseName          : Public
Target            : {}
LinkType          :
Name              : Public
FullName          : C:\Users\Public
Parent            : Users
Exists            : True
Root              : C:\
Extension         : .idlerc
CreationTime      : 12-06-2021 21:22:18
CreationTimeUtc   : 21-06-2021 07:07:50
LastAccessTime    : 16-08-2021 20:53:54
LastAccessTimeUtc : 17-08-2021 03:00:45
LastWriteTime     : 12-06-2021 21:22:18
LastWriteTimeUtc  : 21-06-2021 07:08:01
Attributes        : Directory

```

### Viewing the output in a GUI GridView

To view the output in a gridview in a GUI window, we can use 'Out-GridView'

```powershell
Get-ChildItem | Out-GridView
```

Using this, we can add filters and criteria such as Name, Mode, Length and LastWriteTime

### Reading a file

To read file, we will use 'Get-Content'. It's alias is 'cat'

```powershell
Get-Content .\test.txt
```

Output:

```md
This is a test :)
```

### Changing the directory/folder

If we wish to change the current working directory to 'Arav', we can use 'Set-Location'

```powershell
Set-Location .\Arav
```

It's aliases are 'cd' and 'chdir'

### Moving a file to a different location

This can be done with 'Move-Item'. It's aliases are  'mv' and 'move'

```powershell
Move-Item .\test.txt .\Public
```

Now, 'test.txt' has been moved to the Public folder

### Copying a file to a different location

This can be done with 'Move-Item'. It's aliases are  'cp' and 'copy'

```powershell
Copy-Item .\test.txt .\Public
```

Now,  there is a copy of 'test.txt' in the Public folder and the original file is in the current working directory

### Deleting a file/folder

To delete a file we will use 'Remove-Item'

```powershell
Remove-Item test.txt
```

Upon doing so, 'test.txt' will be PERMANENTLY removed from the system. The same cmdlet can be used to delete a folder. However if the folder contains files, we will have to recursively delete it which can be done by appending '-r', which means recursive.

```powershell
Remove-Item -r .\Public
```

To remove all files in a folder, we would use '*'

```powershell
Remove-Item *
```

Now, all the files in 'Public' and the folder itself have been PERMANENTLY deleted. It's aliases are 'rm', 'del' and 'rmdir'

### Creating a folder

```powershell
New-Item -Directory Test
```

It's alias is 'mkdir'

### Searching for a file with a pattern

To search for a file with a pattern we will use 'Select-String'

To search for all files start with A, we would run the following cmdlet

```powershell
Select-String -Path "." -Pattern "A"
```

### Clearing the screen

```powershell
Clear-Host
```

### Executing Policy 

Determines which powershell scripts can run and which ones cannot. 

Viewing the current policy 

```powershell
Get-ExecutionPolicy
```

Output:

```powershell
Restricted
```

***

Viewing the execution policy for the machine, user, process, current user and local machine

```powershell
Get-ExecutionPolicy -List
```

Output:

```md
        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy       Undefined
   UserPolicy       Undefined
      Process       Undefined
  CurrentUser      Restricted
 LocalMachine      Restricted
```

1. Restricted - Prevents scripts which are downloaded from the internet and written locally from running. Scripts which are signed by a trusted publisher will also not be allowed to run
2. AllSigned - Scripts which are downloaded from the internet or written locally can run , only if they are signed by a trusted publisher. 
3. RemoteSigned - Scripts which are downloaded from the internet have to be signed by a trusted publisher. However, all scripts written locally are allowed to run
4. Unrestricted - All scripts can run, but the user will be warned when running scripts which have been downloaded from the internet
5. Bypass - Does not block any scripts
6. Undefined - No ExecutionPolicy has been set and so the effective policy will be Restricted
<br>To set an execution policy, we will use 'Set-ExecutionPolicy'. Powershell has to be run as the admin to run this cmdlet

```powershell
Set-ExecutionPolicy <Policy Name>
```

We can also set a temporary execution policy for the current session

```powershell
powershell -ExecutionPolicy bypass
```

### Profile

*$profile* is an environment variable which refers to a file named 'Microsoft.PowerShell_profile.ps1'. It is similar to '.bashrc' in linux. This file is stored in a folder named 'WindowsPowershell' in the Documents folder. By default, this folder DOES NOT exist. First we will have to create the folder named 'WindowsPowershell' in 'C:\Users\Arav\Documents\'

```powershell
New-Item -Directory WindowsPowershell
```

Now we can create this file with notepad

```powershell
notepad $profile
```

We can add 'Get-Date' to this file so that the date is displayed when we run powershell. Note: The profile cannot run if the execution policy is set to Restricted or AllSigned

### Processes 

### Basic Scripting

##### Data Types

The data types in powershell are integers, double, strings  and booleans 

```powershell
$test = 100
$test2 = -100
$test3 = 81.346
$test4 = "hello world!"
$test5 = $true
$test6 = $true
```

***

To check the type of a variable, we can use 'GetType()'

```powershell
$test.GetType()
```

Output:

```md
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                                    System.ValueType
```

***

```powershell
$test4.GetType()
```

Output:

```md
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object
```

##### Conditional Statements

Structure:

```powershell
if( Condition ) {
	Statements
}
else if( Condition ){
	Statements
}
else{
	Statements	
}
```

Relational operators:
* -eq: Is equal
* -ne: Not equal
* -gt: Greater than
* -lt: Lesser than
* -ge: Greater than or equal to
* -le: Lesser than or equal to

If we do not want to be case sensitive, we can add 'i' after the '-'. So if we want 'greater than or equal to' to be case sensitive, the operator would be '-cge'
<br>
If we do not want to be case sensitive, we can add 'i' after the '-'. So if we want 'not equal' to be case sensitive, the operator would be '-ine'

##### Input

```powershell
$name = Read-Host "Enter your name"
```

##### Functions

Function with no parameters

```powershell
function Get-Test123{
	Write-Output "Test 123 :)"
}
```

Calling it:

```powershell
Get-Test123
```

***

Function with parameter(s)

```powershell
function add($param1,$param2){
	$a = $param1 + $param2
	Write-Output $a
}
```

Calling it:

```powershell
add -param1 1 -param2 2
```

##### Running a script/module 

Scripts have the file extension of '.ps1'

```powershell
.\test.ps1
```

And modules have the file extension of '.psm1'

```powershell
Import-Module .\test.psm1
```

To check the cmdlets we can run with the module, we will use 'Get-Command'

```powershell
Get-Command -Module test
```

***
